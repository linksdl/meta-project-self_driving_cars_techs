### 3, C++ 关键字与关键库函数

本章将重点涉及以下高频知识点：

1. [sizeof 和 strlen 的区别](https://leetcode.cn/leetbook/read/cmian-shi-tu-po/vw9445/)
2. [C 和 C++ static 中的作用](https://leetcode.cn/leetbook/read/cmian-shi-tu-po/vwrt6c/)
3. [const 作用及用法](https://leetcode.cn/leetbook/read/cmian-shi-tu-po/vwplqi/)
4. [define 和 const 的区别](https://leetcode.cn/leetbook/read/cmian-shi-tu-po/vwmd3e/)
5. [inline 作用及使用方法](https://leetcode.cn/leetbook/read/cmian-shi-tu-po/vwnolj/)
6. [new 和 malloc 的区别](https://leetcode.cn/leetbook/read/cmian-shi-tu-po/vwd4vd/)
7. [delete 与 free 的区别](https://leetcode.cn/leetbook/read/cmian-shi-tu-po/vw0gnh/)
8. [volatile 的作用与使用场景](https://leetcode.cn/leetbook/read/cmian-shi-tu-po/vwudo7/)
9. [用宏实现比较大小，以及两个数中的最小值](https://leetcode.cn/leetbook/read/cmian-shi-tu-po/vw2muv/)
10. [宏定义（define）和内联函数（inline）的区别](https://leetcode.cn/leetbook/read/cmian-shi-tu-po/vwvf0r/)
11. [C 和 C++ struct 的区别](https://leetcode.cn/leetbook/read/cmian-shi-tu-po/vw7qa3/)[struct 和 union 的区别](https://leetcode.cn/leetbook/read/cmian-shi-tu-po/vwltmm/)
12. [extern C 的作用](https://leetcode.cn/leetbook/read/cmian-shi-tu-po/vw8m56/)
13. [strcpy 函数的缺陷](https://leetcode.cn/leetbook/read/cmian-shi-tu-po/vwqjji/)
14. [lambda 表达式的应用](https://leetcode.cn/leetbook/read/cmian-shi-tu-po/vwegz6/)
15. [explicit 的作用](https://leetcode.cn/leetbook/read/cmian-shi-tu-po/vwoqg2/)
16. [define 和 typedef 的区别](https://leetcode.cn/leetbook/read/cmian-shi-tu-po/vwantg/)
17. [inline 函数工作原理](https://leetcode.cn/leetbook/read/cmian-shi-tu-po/vwv57t/)
18. [class 和 struct 的异同](https://leetcode.cn/leetbook/read/cmian-shi-tu-po/vwilr1/)
19. [返回函数中静态变量的地址会发生什么](https://leetcode.cn/leetbook/read/cmian-shi-tu-po/vwtne5/)
20. [sizeof(1==1) 在 C 和 C++ 中的结果](https://leetcode.cn/leetbook/read/cmian-shi-tu-po/vw3ox2/)
21. [memmove 函数的底层原理](https://leetcode.cn/leetbook/read/cmian-shi-tu-po/vwqxfc/)
22. [auto 类型推导的原理](https://leetcode.cn/leetbook/read/cmian-shi-tu-po/vw6ybe/)
23. [new 的作用](https://leetcode.cn/leetbook/read/cmian-shi-tu-po/vwwcws/)

#### 01. sizeof 和 strlen 的区别 5

面试高频指数：★★★★★

* `strlen` 是头文件 `<cstring>` 中的函数，`sizeof` 是 `C++` 中的运算符。`strlen` 测量的是字符串的实际长度（其源代码如下），以 `\0` 结束，而 `sizeof` 测量的是对象或者表达式类型占用的字节大小。`strlen` 源代码如下:

```
size_t strlen(const char *str) {
    size_t length = 0;
    while (*str++)
        ++length;
    return length;
}

```

举例：

```
#include <iostream>
#include <cstring>

using namespace std;

int main()
{
    char arr[10] = "hello";
    cout << strlen(arr) << endl; // 5
    cout << sizeof(arr) << endl; // 10
    return 0;
}

```

若字符数组 `arr` 作为函数的形参，`sizeof(arr)` 中 `arr` 被当作字符指针来处理，`strlen(arr)` 中 `arr` 依然是字符数组，从下述程序的运行结果中就可以看出。

```
#include <iostream>
#include <cstring>

using namespace std;

void size_of(char arr[])
{
    cout << sizeof(arr) << endl; // warning: 'sizeof' on array function parameter 'arr' will return size of 'char*' .
    cout << strlen(arr) << endl; 
}

int main()
{
    char arr[20] = "hello";
    size_of(arr); 
    return 0;
}
/*
输出结果：
8
5
*/

```

二者的不同之处:

* `strlen` 本身是库函数，因此在程序运行过程中，计算长度；而 `sizeof` 是在编译时计算长度；`sizeof` 的参数可以是类型，也可以是变量，且必须是完整类型；`strlen` 的参数必须是 `char *` 类型的变量。
* `sizeof` 接受的参数可以是对象也可以是表达式，但是 `sizeof(expression)` 在运行时不会对接受的表达式进行计算，编译器只会推导表达式的类型从而计算占用的字节大小；而 `strlen` 是一个函数，如果接受表达式则会对表达式进行运算。

```
  #include <iostream>
  using namespace std;
  int main(int argc, char * argv[])
  {
      int x = 4;
      char *s = "12345678";
      char *p = s;
      sizeof(x++);
      printf("%d\n", x);
      strlen(p++);
      return 0;
  }

```

* 对于 `C99` 中结构体允许最后一个变量为不定长数组，`sizeof` 则不计算空间。

```
  #include <iostream>
  #include <cstring>

  using namespace std;

  struct flexarray {
      int val;
      int array[];  /* Flexible array member; must be last element of struct */
  };

  int main()
  {
      printf("%ld\n", sizeof(struct flexarray)); // 4
  }

```

参考资料：

* [sizeof](https://leetcode.cn/link/?target=https://en.wikipedia.org/wiki/Sizeof)
* [sizeof operator in C](https://leetcode.cn/link/?target=https://www.geeksforgeeks.org/sizeof-operator-c/)
* [sizeof operator](https://leetcode.cn/link/?target=https://en.cppreference.com/w/cpp/language/sizeof)


#### 18. inline 函数工作原理 3

面试高频指数：★★★☆☆

1. 内联函数的工作原理：

* 内联函数不是在调用时发生控制转移关系，而是在编译阶段将函数体嵌入到每一个调用该函数的语句块中，编译器会将程序中出现内联函数的调用表达式用内联函数的函数体来替换。函数调用时，需要切换栈帧寄存器，同时栈中压入参数、返回值，然后进行跳转，这些都需要开销，而内联函数则可以不要这些开销，直接将内联函数中函数体直接插入或者替换到该函数调用点。
* 普通函数是将程序执行转移到被调用函数所存放的内存地址，当函数执行完后，返回到执行此函数前的地方。转移操作需要保护现场，被调函数执行完后，再恢复现场，该过程需要较大的资源开销。
* 虽然内联函数在调用时直接进行展开，但实际在编译后代码中存在内联函数的定义，可以供编译器进行调用。普通函数可以有指向它的函数指针，内敛函数也可以有指向它的函数指针。

2. 内联函数的优缺点:

* 内联函数具有以下优点：

  * 不会产生函数调用开销。节省了调用函数时在堆栈上推送/弹出变量的开销。节省了函数返回调用的开销。当你内联一个函数时，你可以让编译器对函数体执行上下文特定的优化，其他优化可以通过考虑调用上下文和被调用上下文的流程来获得，而对于普通函数不会有这种优化。
* 内联函数的缺点：

  * 从内联函数中添加的变量会消耗额外的寄存器，在内联函数之后，如果要使用寄存器的变量数量增加，则可能会在寄存器变量资源利用方面产生开销。在函数调用点替换内联函数体时，函数使用的变量总数也会增加，用于存储变量的寄存器数量也会增加。因此，如果在函数内联变量数量急剧增加之后，它肯定会导致寄存器利用率的开销。
  * 如果你使用太多的内联函数，那么二进制可执行文件的大小会很大，因为相同的代码重复。
  * 过多的内联也会降低指令缓存命中率，从而降低从缓存内存到主内存的指令获取速度。
  * 如果有人更改内联函数内的代码，内联函数可能会增加编译时间开销，那么所有调用位置都必须重新编译，因为编译器需要再次替换所有代码，否则它将继续使用旧功能.
  * 内联函数可能会导致抖动，因为内联可能会增加二进制可执行文件的大小。内存抖动会导致计算机性能下降。

3. `inline` 函数的使用场景：
   内联函数一般只适用于比较短小，处理较为简单的函数。内联只是对编译器的请求，而不是命令。编译器可以忽略内联请求。编译器可能不会在以下情况下执行内联：

* 如果函数包含循环（`for, while, do-while`）；
* 如果一个函数包含静态变量；
* 如果一个函数是递归的；
* 如果函数返回类型不是 `void`，并且函数体中不存在 `return` 语句；
* 如果函数包含 `switch` 或 `goto` 语句；

4. 内联可以去除函数只能定义一次的限制：
   内联函数可以在程序中定义不止一次， 但是 `inline` 函数的定义在某个源文件中只能出现一次，而且在所有源文件中，其定义必须是完全相同的。一般情况下，我们可以在头文件中定义 `inline` 函数，所有 `include` 该头文件，如果修改了头文件中的 `inline` 函数时，使用了该头文件的所有源文件都必须重新编译。比如我们可以在定义以下两个文件包含相同的函数。

```
// b.cpp
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

inline int min(int a, int b) {
    return a + b;
}

// a.cpp
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

inline int min(int a, int b) {
    return a + b;
}

int main() {
    int a = 10, b = 9;
    min(a, b);
    return 0;
}


```

参考资料：

* [Inline Functions in C++](https://leetcode.cn/link/?target=https://www.***.org/inline-functions-cpp/?ref=gcse)
* [Inline function](https://leetcode.cn/link/?target=https://en.wikipedia.org/wiki/Inline_function)



#### 19. class 和 struct 的异同 3

面试高频指数：★★★☆☆

`C++` 中为了兼容 `C` 语言而保留了 `C` 语言的 `struct` 关键字，并且加以扩充。在 `C` 语言中，`struct` 只能包含成员变量，不能包含成员函数。而在 `C++` 中，`struct` 类似于 `class`，既可以包含成员变量，又可以包含成员函数。
`C++` 中的 `struct` 和 `class` 基本是通用的，唯有几个细节不同：

* `class` 中类中的成员默认都是 `private` 属性的；而在 `struct` 中结构体中的成员默认都是 `public` 属性的。
* `class` 继承默认是 `private` 继承，而 `struct` 继承默认是 `public` 继承。
* `class` 可以用于定义模板参数，`struct` 不能用于定义模板参数。

```
struct A{}；
class B : A{}; // private 继承 
struct C : B{}； // public 继承
```

举例：

```
#include<iostream>

using namespace std;

class A{
public:
    void funA(){
        cout << "class A" << endl;
    }
};

struct B: A{ // 由于 B 是 struct，A 的默认继承级别为 public
public:
    void funB(){
        cout << "class B" << endl;
    }
};

class C: B{ // 由于 C 是 class，B 的默认继承级别为 private，所以无法访问基类 B 中的 printB 函数

};

int main(){
    A ex1;
    ex1.funA(); // class A

    B ex2;
    ex2.funA(); // class A
    ex2.funB(); // class B

    C ex3;
    ex3.funB(); // error: 'B' is not an accessible base of 'C'.
    return 0;
}

```


参考资料：

* [Inline Functions in C++](https://leetcode.cn/link/?target=https://www.ibm.com/docs/en/zos/2.3.0?topic=only-classes-structures-c)
* [Difference between Structure and Class in C++](https://leetcode.cn/link/?target=https://www.javatpoint.com/structure-vs-class-in-cpp)

#### 20. 返回函数中静态变量的地址会发生什么 3

面试高频指数：★★★☆☆

```
#include <iostream>
using namespace std;

int * fun(int tmp){
    static int var = 10;
    var *= tmp;
    return &var;
}

int main() {
    cout << *fun(5) << endl;
    return 0;
}

/*
运行结果：
50
*/

```

* 前面的章节中讲过，静态局部变量存在静态区，程序初始化时则已经创建了改变量，变量的生存周期为整个程序的生命周期。上述代码中在函数 `fun` 中定义了静态局部变量 `var`，使得离开该函数的作用域后，该变量不会销毁，返回到主函数中，该变量依然存在，从而使程序得到正确的运行结果，该静态局部变量直到程序运行结束后才销毁。
* 需要注意的是，全局静态对象在程序初始化时，则进行了初始化。局部静态对象的初始化在第一次进入函数内部时，才会调用对象的构造函数进行初始化。程序退出时，先释放静态局部变量，再释放全局静态变量。

参考资料：

* [线程安全：局部静态变量的初始化](https://leetcode.cn/link/?target=https://baijiahao.baidu.com/s?id=1686962192046161801&wfr=spider&for=pc)
* [static初始化](https://leetcode.cn/link/?target=https://zhuanlan.zhihu.com/p/406301228)




#### 21. sizeof(1==1) 在 C 和 C++ 中的结果 3

面试高频指数：★★★☆☆

前面的章节中讲述过 `sizeof` 接受的参数可以是对象也可以是表达式，但是 `sizeof(expression)` 在运行时不会对接受的表达式进行计算，编译器只会推导表达式的类型从而计算占用的字节大小；

```
#include <iostream>
using namespace std;
int main(int argc, char * argv[])
{
    int x = 4;
    sizeof(x++);
    printf("%d\n", x);
    return 0;
}

```

* 由于 `C` 语言没有 `bool` 类型，用整形表示布尔型，因此下面的程序返回 `4`;

```
#include<stdio.h>

void main(){
    printf("%d\n", sizeof(1==1));
}

/*
运行结果：
4
*/

```

* 由于 `C++` 语言有 `bool` 类型，布尔型占 `1` 个字节，因此下面的程序返回 `1`;

```
#include <iostream>
using namespace std;

int main() {
    cout << sizeof(1==1) << endl;
    return 0;
}

/*
1
*/

```

参考资料：

* [sizeof operator in C](https://leetcode.cn/link/?target=https://www.***.org/sizeof-operator-c/)

#### 22. memmove 函数的底层原理 3

面试高频指数：★★★☆☆

* `memmove` 用于拷贝字节，如果目标区域和源区域有重叠的话，`memmove` 能够保证源串在被覆盖之前将重叠区域的字节拷贝到目标区域中，但复制后源内容会被更改。但是当目标区域与源区域没有重叠则和 `memcpy` 函数功能相同。面试时会经常要求实现 `memmove` 函数，在实现的时候需要特殊处理地址重叠的情况。

```
void *memmove(void *dst, const void *src, size_t size)
{
    char *psrc;
    char *pdst;

    if (NULL == dst || NULL == src)
    {
        return NULL;
    }

    if ((src < dst) && (char *)src + size > (char *)dst) // 出现地址重叠的情况，自后向前拷贝
    {
        psrc = (char *)src + size - 1;
        pdst = (char *)dst + size - 1;
        while (size--)
        {
            *pdst-- = *psrc--;
        }
    }
    else
    {
        psrc = (char *)src;
        pdst = (char *)dst;
        while (size--)
        {
            *pdst++ = *psrc++;
        }
    }

    return dst;
}

```

参考资料：

* [memmove() in C/C++](https://leetcode.cn/link/?target=https://www.***.org/memmove-in-cc/?ref=gcse)

#### 23. new 的作用 2

面试高频指数：★★☆☆☆

1. `new` 的简介：
   `new` 是 `C++` 中的关键字，尝试分配和初始化指定或占位符类型的对象或对象数组，并返回指向对象 (或数组的初始对象) 的指针。

* 用 `new` 创建对象时，首先从堆中申请相应的内存空间，然后调用对象的构造函数，最后返回指向对象的指针。`new` 操作符从自由存储区（`free store`）上为对象动态分配内存空间，而 `malloc` 函数从堆上动态分配内存。自由存储区是 `C++` 基于 `new` 操作符的一个抽象概念，凡是通过 `new` 操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，`C` 语言使用 `malloc` 从堆上分配内存，使用 `free` 释放已分配的对应内存。`new` 可以指定在内存地址空间创建对象，用法如下:

```
new (place_address) type
```

`place_address` 为一个指针，代表一块内存的地址。当使用上面这种仅以一个地址调用 `new` 操作符时，`new` 操作符调用特殊的 `operator new`：

```
void * operator new (size_t, void *) 
```

对于指定的地址的 `new` 对象，在释放时，不能直接调用 `delete`, 应该先调用对象的析构函数，然后再对内存进行释放。比如以下程序:

```
include <iostream>
using namespace std;

int main(int argc, char* argv[])
{
    char buf[100];
    int *p=new (buf) int(101);
    cout<<*(int*)buf<<endl;
    return 0;
}

```

* `new` 可以用来动态生成对象数组，但此时 `new` 生成的数组，只能用 `delete` 来释放。

```
int *arr = new int [100];
```

* 在 `cpp` 中由于 `new` 作为操作符可以进行重载，所以可以对 `new` 进行重载，比如可以指定构造函数对对象进行初始化。对 `new` 操作符可以进行全局重载和局部重载，全局重载后，所有调用 `new` 的操作都会被重写；局部重载就是在类中重写 `operator new` 函数，但只会对该类生效，即该类执行 `new` 操作时会生效。

```
#include <iostream>

class Test {
private:
    int value;

public:
    Test() {
        printf("[Test] Constructor\n");
    }

    void* operator new(size_t size) {
        printf("[Test] operator new\n");
        return NULL;
    }
};

int main() 
{ 
    Test* t = new Test();
    return 0;
}

// [Test] operator new
// [Test] Constructor

```

参考资料：

* [new (C++)](https://leetcode.cn/link/?target=https://zh.m.wikipedia.org/zh/New_(C%2B%2B))
* [C++ new的三种面貌](https://leetcode.cn/link/?target=https://cloud.tencent.com/developer/article/1177460)
* [new 运算符 (C++)](https://leetcode.cn/link/?target=https://docs.microsoft.com/zh-cn/cpp/cpp/new-operator-cpp?view=msvc-170)
