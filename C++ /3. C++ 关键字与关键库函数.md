### 3, C++ 关键字与关键库函数

本章将重点涉及以下高频知识点：

1. [sizeof 和 strlen 的区别](https://leetcode.cn/leetbook/read/cmian-shi-tu-po/vw9445/)
2. [C 和 C++ static 中的作用](https://leetcode.cn/leetbook/read/cmian-shi-tu-po/vwrt6c/)
3. [const 作用及用法](https://leetcode.cn/leetbook/read/cmian-shi-tu-po/vwplqi/)
4. [define 和 const 的区别](https://leetcode.cn/leetbook/read/cmian-shi-tu-po/vwmd3e/)
5. [inline 作用及使用方法](https://leetcode.cn/leetbook/read/cmian-shi-tu-po/vwnolj/)
6. [new 和 malloc 的区别](https://leetcode.cn/leetbook/read/cmian-shi-tu-po/vwd4vd/)
7. [delete 与 free 的区别](https://leetcode.cn/leetbook/read/cmian-shi-tu-po/vw0gnh/)
8. [volatile 的作用与使用场景](https://leetcode.cn/leetbook/read/cmian-shi-tu-po/vwudo7/)
9. [用宏实现比较大小，以及两个数中的最小值](https://leetcode.cn/leetbook/read/cmian-shi-tu-po/vw2muv/)
10. [宏定义（define）和内联函数（inline）的区别](https://leetcode.cn/leetbook/read/cmian-shi-tu-po/vwvf0r/)
11. [C 和 C++ struct 的区别](https://leetcode.cn/leetbook/read/cmian-shi-tu-po/vw7qa3/)[struct 和 union 的区别](https://leetcode.cn/leetbook/read/cmian-shi-tu-po/vwltmm/)
12. [extern C 的作用](https://leetcode.cn/leetbook/read/cmian-shi-tu-po/vw8m56/)
13. [strcpy 函数的缺陷](https://leetcode.cn/leetbook/read/cmian-shi-tu-po/vwqjji/)
14. [lambda 表达式的应用](https://leetcode.cn/leetbook/read/cmian-shi-tu-po/vwegz6/)
15. [explicit 的作用](https://leetcode.cn/leetbook/read/cmian-shi-tu-po/vwoqg2/)
16. [define 和 typedef 的区别](https://leetcode.cn/leetbook/read/cmian-shi-tu-po/vwantg/)
17. [inline 函数工作原理](https://leetcode.cn/leetbook/read/cmian-shi-tu-po/vwv57t/)
18. [class 和 struct 的异同](https://leetcode.cn/leetbook/read/cmian-shi-tu-po/vwilr1/)
19. [返回函数中静态变量的地址会发生什么](https://leetcode.cn/leetbook/read/cmian-shi-tu-po/vwtne5/)
20. [sizeof(1==1) 在 C 和 C++ 中的结果](https://leetcode.cn/leetbook/read/cmian-shi-tu-po/vw3ox2/)
21. [memmove 函数的底层原理](https://leetcode.cn/leetbook/read/cmian-shi-tu-po/vwqxfc/)
22. [auto 类型推导的原理](https://leetcode.cn/leetbook/read/cmian-shi-tu-po/vw6ybe/)
23. [new 的作用](https://leetcode.cn/leetbook/read/cmian-shi-tu-po/vwwcws/)

#### 01. sizeof 和 strlen 的区别 5

面试高频指数：★★★★★

* `strlen` 是头文件 `<cstring>` 中的函数，`sizeof` 是 `C++` 中的运算符。`strlen` 测量的是字符串的实际长度（其源代码如下），以 `\0` 结束，而 `sizeof` 测量的是对象或者表达式类型占用的字节大小。`strlen` 源代码如下:

```
size_t strlen(const char *str) {
    size_t length = 0;
    while (*str++)
        ++length;
    return length;
}

```

举例：

```
#include <iostream>
#include <cstring>

using namespace std;

int main()
{
    char arr[10] = "hello";
    cout << strlen(arr) << endl; // 5
    cout << sizeof(arr) << endl; // 10
    return 0;
}

```

若字符数组 `arr` 作为函数的形参，`sizeof(arr)` 中 `arr` 被当作字符指针来处理，`strlen(arr)` 中 `arr` 依然是字符数组，从下述程序的运行结果中就可以看出。

```
#include <iostream>
#include <cstring>

using namespace std;

void size_of(char arr[])
{
    cout << sizeof(arr) << endl; // warning: 'sizeof' on array function parameter 'arr' will return size of 'char*' .
    cout << strlen(arr) << endl; 
}

int main()
{
    char arr[20] = "hello";
    size_of(arr); 
    return 0;
}
/*
输出结果：
8
5
*/

```

二者的不同之处:

* `strlen` 本身是库函数，因此在程序运行过程中，计算长度；而 `sizeof` 是在编译时计算长度；`sizeof` 的参数可以是类型，也可以是变量，且必须是完整类型；`strlen` 的参数必须是 `char *` 类型的变量。
* `sizeof` 接受的参数可以是对象也可以是表达式，但是 `sizeof(expression)` 在运行时不会对接受的表达式进行计算，编译器只会推导表达式的类型从而计算占用的字节大小；而 `strlen` 是一个函数，如果接受表达式则会对表达式进行运算。

```
  #include <iostream>
  using namespace std;
  int main(int argc, char * argv[])
  {
      int x = 4;
      char *s = "12345678";
      char *p = s;
      sizeof(x++);
      printf("%d\n", x);
      strlen(p++);
      return 0;
  }

```

* 对于 `C99` 中结构体允许最后一个变量为不定长数组，`sizeof` 则不计算空间。

```
  #include <iostream>
  #include <cstring>

  using namespace std;

  struct flexarray {
      int val;
      int array[];  /* Flexible array member; must be last element of struct */
  };

  int main()
  {
      printf("%ld\n", sizeof(struct flexarray)); // 4
  }

```

参考资料：

* [sizeof](https://leetcode.cn/link/?target=https://en.wikipedia.org/wiki/Sizeof)
* [sizeof operator in C](https://leetcode.cn/link/?target=https://www.geeksforgeeks.org/sizeof-operator-c/)
* [sizeof operator](https://leetcode.cn/link/?target=https://en.cppreference.com/w/cpp/language/sizeof)


#### 12. C 和 C++ struct 的区别 4

面试高频指数：★★★★☆

* 在 `C<span> </span>`语言中 struct 是用户自定义数据类型；在 `C++` 中 `struct` 是抽象数据类型，支持成员函数的定义。`C++` 中的 `class` 可以实现 `struct` 的所有功能，`C++` 为了兼容 `C` 语言保留了 `struct` 关键字。
* `C` 语言中 `struct` 没有访问权限的设置，是一些变量的集合体，不能定义成员函数；`C++` 中 `struct` 可以和类一样，有访问权限，并可以定义成员函数。
* `C` 语言中 `struct` 定义的自定义数据类型，在定义该类型的变量时，需要加上 `struct` 关键字，例如：`struct A var;`，定义 `A` 类型的变量；而 `C++` 中，不用加该关键字，例如：`A var`。
* `C++` 中 `struct` 可以继承，也可以实现多态，而 `C` 语言中不支持继承和多态。

参考资料：

* [【C++】struct和class的区别](https://leetcode.cn/link/?target=https://zhuanlan.zhihu.com/p/47808468)


#### 13. extern C 的作用 4

面试高频指数：★★★★☆

`C` 和 `C++` 对同一个函数经过编译后生成的函数名是不同的，由于 `C++` 支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的函数名中，而不仅仅是原始的函数名。比如以下函数，同一个函数 `test` 在 `C++` 编译后符号表中生成的函数名可能为 `_Z4testv`，而 `C` 编译后符号表中生成的函数名可能为 `test`。
比如同一个函数:

```
int test() {
    return 0;
}
```

* 由于 `C` 语言并不支持函数重载，在 `C` 语言中函数不能重名，因此编译 `C` 语言代码的函数时不会带上函数的参数类型，一般只包括函数名。如果在 `C++` 中调用一个使用 `C` 语言编写的模块中的某个函数 `test`，`C++` 是根据 `C++` 的函数名称修饰方式来查找并链接这个函数，去在生成的符号表查找 `_Z4testv` 这个函数的代码，此时就会发生链接错误。而此时我们用 `extern C` 声明，那么在链接时，`C++` 编译器则按照 `C` 语言的函数命名规则 `test` 去符号表中查找对应的函数。因此当 `C++` 程序需要调用 `C` 语言编写的函数，`C++` 使用链接指示，即 `extern "C"` 指出任意非 `C++` 函数所用的语言。

```
// 可能出现在 C++ 头文件<cstring>中的链接指示
extern "C"{
    int strcmp(const char*, const char*);
}

```

参考资料：

* [extern (C++)](https://leetcode.cn/link/?target=https://docs.microsoft.com/en-us/cpp/cpp/extern-cpp?view=msvc-170)


#### 12. struct 和 union 的区别 4

面试高频指数：★★★★☆

* `union` 是联合体，`struct` 是结构体。`union` 中的所有成员变量共享同一段内存空间，`struct` 中的每个成员变量独占内存空间。
* 联合体和结构体都是由若干个数据类型不同的数据成员组成。使用时，联合体只有一个有效的成员；而结构体所有的成员都有效。
* 对联合体的不同成员赋值，将会对覆盖其他成员的值，而对于结构体的对不同成员赋值时，相互不影响。
* 联合体的大小为其内部所有变量的最大值，按照最大类型的倍数进行分配大小；结构体分配内存的大小遵循内存对齐原则。
* `struct` 可以定义变长数组成员变量 `int a[]`，`union` 中不能包含有这种不确定长度的变量。
  以下为示例程序:

```
#include <iostream>
using namespace std;

typedef union
{
    char c[10];
    char cc1; // char 1 字节，按该类型的倍数分配大小
} u11;

typedef union
{
    char c[10];
    int i; // int 4 字节，按该类型的倍数分配大小
} u22;

typedef union
{
    char c[10];
    double d; // double 8 字节，按该类型的倍数分配大小
} u33;

typedef struct s1
{
    char c;   // 1 字节
    double d; // 1（char）+ 7（内存对齐）+ 8（double）= 16 字节
} s11;

typedef struct s2
{
    char c;   // 1 字节
    char cc;  // 1（char）+ 1（char）= 2 字节
    double d; // 2 + 6（内存对齐）+ 8（double）= 16 字节
} s22;

typedef struct s3
{
    char c;   // 1 字节
    double d; // 1（char）+ 7（内存对齐）+ 8（double）= 16 字节
    char cc;  // 16 + 1（char）+ 7（内存对齐）= 24 字节
} s33;

int main()
{
    cout << sizeof(u11) << endl; // 10
    cout << sizeof(u22) << endl; // 12
    cout << sizeof(u33) << endl; // 16
    cout << sizeof(s11) << endl; // 16
    cout << sizeof(s22) << endl; // 16
    cout << sizeof(s33) << endl; // 24

    cout << sizeof(int) << endl;    // 4
    cout << sizeof(double) << endl; // 8
    return 0;
}

```


参考资料：

* [Difference between Structure and Union in C](https://leetcode.cn/link/?target=https://www.***.org/difference-structure-union-c/)
* [Difference Between Structure and Union in C](https://leetcode.cn/link/?target=https://www.guru99.com/difference-structure-union-c.html)
* [Understanding the Difference Between Structure and Union in C](https://leetcode.cn/link/?target=https://www.naukri.com/learning/articles/difference-between-structure-and-union-in-c/)


#### 14. strcpy 函数的缺陷 4

面试高频指数：★★★★☆

1. `strcpy` 函数的实现:
   `strcpy` 是 `C++` 语言的一个标准函数 ，`strcpy` 把含有 `'\0'` 结束符的字符串复制到另一个地址空间，返回值的类型为 `char*`，返回值为拷贝后的字符串的首地址。

```
char * strcpy(char * strDest,const char * strSrc) {
    if ((NULL==strDest) || (NULL==strSrc)) 
    throw "Invalid argument(s)"; 
    char * strDestCopy = strDest; 
    while ((*strDest++=*strSrc++)!='\0'); 
    return strDestCopy;
}

```

2. `strcpy` 函数的缺陷：`strcpy` 函数不检查目的缓冲区的大小边界，而是将源字符串逐一的全部赋值给目的字符串地址起始的一块连续的内存空间，同时加上字符串终止符，会导致其他变量被覆盖。

```
#include <iostream>
#include <cstring>
using namespace std;

int main()
{
    int var = 0x11112222;
    char arr[10];
    cout << "Address : var " << &var << endl;
    cout << "Address : arr " << &arr << endl;
    strcpy(arr, "hello world!");
    cout << "var:" << hex << var << endl; // 将变量 var 以 16 进制输出
    cout << "arr:" << arr << endl;
    return 0;
}

/*
Address : var 0x23fe4c
Address : arr 0x23fe42
var:11002164
arr:hello world!
*/

```


说明：从上述代码中可以看出，变量 `var` 的后六位被字符串 `"hello world!"` 的 `"d!\0"` 这三个字符改变，这三个字符对应的 `ascii` 码的十六进制为：`\0(0x00)，!(0x21)，d(0x64)`。
原因：变量 `arr` 只分配的 `10` 个内存空间，通过上述程序中的地址可以看出 `arr` 和 `var` 在内存中是连续存放的，但是在调用 `strcpy` 函数进行拷贝时，源字符串 `"hello world!"` 所占的内存空间为 `13`，因此在拷贝的过程中会占用 `var` 的内存空间，导致 `var` 的后六位被覆盖。由于 `strcpy` 函数存在一定的安全风险，如果使用不当容易出现安全问题，利用 `strcpy` 的特性可以编写 `shellcode` 来进行缓冲区溢出攻击。在大多数工程代码中，为了保证代码的健壮性和安全性，一般会使用 `strncpy` 代替 `strcpy`。

参考资料：

* [strcpy in C/C++](https://leetcode.cn/link/?target=https://www.***.org/strcpy-in-c-cpp/)
* [strcpy](https://leetcode.cn/link/?target=https://cplusplus.com/reference/cstring/strcpy/)


#### 15. lambda 表达式的应用 3

面试高频指数：★★★☆☆

`lambda` 表达式，又被称为 `lambda` 函数或者 `lambda` 匿名函数。
`lambda` 匿名函数的定义:

```
[capture list] (parameter list) -> return type
{
function body;
};
```

其中：

* `capture list`：捕获列表，指 `lambda` 所在函数中定义的局部变量的列表。定义在与 `lambda` 函数相同作用域的参数引用也可以被使用，一般被称作 `closure`（闭包），以下为闭包的常见用法。

```
[]      // 没有定义任何变量。使用未定义变量会引发错误。
[x, &y] // x以传值方式传入（默认），y以引用方式传入。
[&]     // 任何被使用到的外部变量都隐式地以引用方式加以引用。
[=]     // 任何被使用到的外部变量都隐式地以传值方式加以引用。
[&, x]  // x显式地以传值方式加以引用。其余变量以引用方式加以引用。
[=, &z] // z显式地以引用方式加以引用。其余变量以传值方式加以引用。

```

比如下面以引用的方式调用 `a`：

```
int main()
{
    int a = 10;
    auto f = [&a](int x)-> int {
        a = 20;
        return a + x;
    };
    cout<<a<<endl; // 10
    cout<<f(10)<<endl; // 30
    cout<<a<<endl; // 20
    return 0;
}

```

* `return type`、`parameter list`、`function body`：分别表示返回值类型、参数列表、函数体，和普通函数一样。
  举例：

```
#include <iostream>
#include <algorithm>
using namespace std;

int main()
{
    int arr[4] = {4, 2, 3, 1};
    //对 a 数组中的元素进行升序排序
    sort(arr, arr + 4, [=](int x, int y) -> bool{ return x < y; } );
    auto f = [&](int x)-> int {
        return arr[0] + x;
    }

    for(int n : arr){
        cout << n << " ";
    }
    return 0;
}

```


* 需要注意的是 `lambda` 函数按照值方式捕获的环境中的变量，在 `lambda` 函数内部是不能修改的，否则编译器会报错。其值是 `lambda` 函数定义时捕获的值，不再改变。如果在 `lambda` 函数定义时加上 `mutable` 关键字，则该捕获的传值变量在 `lambda` 函数内部是可以修改的，对同一个 `lambda` 函数的随后调用也会累加影响该捕获的传值变量，但对外部被捕获的那个变量本身无影响。

```
#include <iostream> 
using namespace std;
int main()
{
	size_t t = 9;
	auto f = [t]() mutable{
		t++;
		return t; 
	};
	cout << f() << endl; // 10
	t = 100;
	cout << f() << endl; // 11
	cout << "t:" << t << endl; // t: 100
	return 0;
}

```

* 引用捕获可能带来悬挂引用常见于使用 `lambda` 表达式使用引用捕获某个局部变量，而调用 `lambda` 表达式时，局部变量已经被清理导致捕获的引用指向被清理的内存空间，从而产生悬挂引用。比如下面程序实例中，当 `GetFunc` 返回时，`s` 的对象已经被销毁，此时 `s` 的引用则会出现问题，应将其修改为值传递。

```
#include <iostream>
#include <cstring>
#include <functional>

auto GetFunc(){
    std::string s = "112234234234";
    return [&](){ std::cout << s << std::endl; };
}

int main(int, char*[]){
    auto func = GetFunc();
    func();
    return 0;
}

```

* 在 `C++ 14` 以后，`lambda` 函数的形式参数允许泛型和初始化捕获。
  返回值和参数均使用泛型，编译器会根据实际进行类型推导。

```
auto lambda = [](auto x, auto y) {return x + y;}
lambda(1, 2);
lambda(1.0, 2.0);

```

允许在 `lambda` 捕获列表中对变量进行表达式赋值，并且支持定义新的变量并进行初始化。

auto lambda = [value = 1] {return value;}

* `C++ 17` 以后，`lambda` 函数也支持使用用 `constexpr` 修饰，此时 `lambda` 函数内部应当满足 `constexpr` 的要求。

```
int y = 32;
auto answer = [y]() constexpr
{
    int x = 10;
    return y + x;
};

constexpr int Increment(int n)
{
    return [n] { return n + 1; }();
}

```

参考资料：

* [C++11](https://leetcode.cn/link/?target=https://zh.wikipedia.org/wiki/C%2B%2B11)
* [Lambda expressions (since C++11)](https://leetcode.cn/link/?target=https://en.cppreference.com/w/cpp/language/lambda)
* [Lambda expressions in C++](https://leetcode.cn/link/?target=https://docs.microsoft.com/en-us/cpp/cpp/lambda-expressions-in-cpp?view=msvc-170)
* [What is a lambda expression in C++11?](https://leetcode.cn/link/?target=https://stackoverflow.com/questions/7627098/what-is-a-lambda-expression-in-c11)



#### 16. explicit 的作用 3

面试高频指数：★★★☆☆

用来声明类构造函数是显式调用的，而非隐式调用，可以阻止调用构造函数时进行隐式转换和赋值初始化。只可用于修饰单参构造函数，因为无参构造函数和多参构造函数本身就是显式调用的，再加上 `explicit` 关键字也没有什么意义。

隐式转换：

```
#include <iostream>
#include <cstring>
using namespace std;

class A
{
public:
    int var;
    A(int tmp)
    {
        var = tmp;
    }
};
int main()
{
    A ex = 10; // 发生了隐式转换
    return 0;
}


```

上述代码中，`A ex = 10`; 在编译时，进行了隐式转换，将 `10` 转换成 `A` 类型的对象，然后将该对象赋值给 `ex`，等同于如下操作：

```
A ex1(10);
A ex = ex1;
```

为了避免隐式转换，可用 `explicit` 关键字进行声明：

```
#include <iostream>
#include <cstring>
using namespace std;

class A
{
public:
    int var;
    explicit A(int tmp)
    {
        var = tmp;
        cout << var << endl;
    }
};
int main()
{
    A ex(100);
    A ex1 = 10; // error: conversion from 'int' to non-scalar type 'A' requested
    return 0;
}

```

* 在日常使用时一般情况下建议声明 `explicit` 的构造函数，从而可以阻止编译器执行非预期 (往往也不被期望) 的类型转换，因为某些非预期的类型转换可能会引起意向不到的错误。

参考资料：

* [C++ explicit 关键字](https://leetcode.cn/link/?target=https://zhuanlan.zhihu.com/p/52152355)
* [What does the explicit keyword mean?](https://leetcode.cn/link/?target=https://stackoverflow.com/questions/121162/what-does-the-explicit-keyword-mean)
* [explicit specifier
  ](https://leetcode.cn/link/?target=https://en.cppreference.com/w/cpp/language/explicit)


#### 17. define 和 typedef 的区别 3

面试高频指数：★★★☆☆

二者之间的区别:

* `#define` 作为预处理指令，在编译预处理时进行替换操作，不作正确性检查，只有在编译已被展开的源程序时才会发现可能的错误并报错。`typedef` 是关键字，在编译时处理，有类型检查功能，用来给一个已经存在的类型一个别名，但不能在一个函数定义里面使用 `typedef` 。
* `typedef` 用来定义类型的别名，方便使用。`#define` 不仅可以为类型取别名，还可以定义常量、变量、编译开关等。
* `#define` 没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用，如果在 `.cpp` 文件中定义了宏，则在整个文件中都可以使用该宏，如果在 `.h` 文件中定义了宏，则只要包含该头文件都可以使用；而 `typedef` 有自己的作用域，如果在函数之外定义了类型，则在整个文件中都可以使用该类型定义，如果在函数内部定义了该类型，则只能在函数内部使用该类型。
* 指针的操作：`typedef` 和 `#define` 在处理指针时不完全一样。比如以下程序：

```
#include <stdio.h>
typedef char* ptr;
#define PTR char*
int main()
{
	ptr a, b, c;
	PTR x, y, z;
	printf("sizeof a:%zu\n" ,sizeof(a) );
	printf("sizeof b:%zu\n" ,sizeof(b) );
	printf("sizeof c:%zu\n" ,sizeof(c) );
	printf("sizeof x:%zu\n" ,sizeof(x) );
	printf("sizeof y:%zu\n" ,sizeof(y) );
	printf("sizeof z:%zu\n" ,sizeof(z) );
	return 0;
}

```

输出为:

```
sizeof a:8
sizeof b:8
sizeof c:8
sizeof x:8
sizeof y:1
sizeof z:1
```

由于在处理，`typedef` 定义了新的类型，因此变量 `a, b, c` 都属于指针类型，而 `#define` 只是做了简单的替换，被替换为语句 `char *x, y, z` 实际 `y,z` 为 `char` 类型。

参考资料：

* [typedef versus #define in C](https://leetcode.cn/link/?target=https://www.***.org/typedef-versus-define-c/)
* [Difference between typedef and define in C](https://leetcode.cn/link/?target=https://www.javatpoint.com/typedef-vs-define-in-c)





#### 18. inline 函数工作原理 3

面试高频指数：★★★☆☆

1. 内联函数的工作原理：

* 内联函数不是在调用时发生控制转移关系，而是在编译阶段将函数体嵌入到每一个调用该函数的语句块中，编译器会将程序中出现内联函数的调用表达式用内联函数的函数体来替换。函数调用时，需要切换栈帧寄存器，同时栈中压入参数、返回值，然后进行跳转，这些都需要开销，而内联函数则可以不要这些开销，直接将内联函数中函数体直接插入或者替换到该函数调用点。
* 普通函数是将程序执行转移到被调用函数所存放的内存地址，当函数执行完后，返回到执行此函数前的地方。转移操作需要保护现场，被调函数执行完后，再恢复现场，该过程需要较大的资源开销。
* 虽然内联函数在调用时直接进行展开，但实际在编译后代码中存在内联函数的定义，可以供编译器进行调用。普通函数可以有指向它的函数指针，内敛函数也可以有指向它的函数指针。

2. 内联函数的优缺点:

* 内联函数具有以下优点：

  * 不会产生函数调用开销。节省了调用函数时在堆栈上推送/弹出变量的开销。节省了函数返回调用的开销。当你内联一个函数时，你可以让编译器对函数体执行上下文特定的优化，其他优化可以通过考虑调用上下文和被调用上下文的流程来获得，而对于普通函数不会有这种优化。
* 内联函数的缺点：

  * 从内联函数中添加的变量会消耗额外的寄存器，在内联函数之后，如果要使用寄存器的变量数量增加，则可能会在寄存器变量资源利用方面产生开销。在函数调用点替换内联函数体时，函数使用的变量总数也会增加，用于存储变量的寄存器数量也会增加。因此，如果在函数内联变量数量急剧增加之后，它肯定会导致寄存器利用率的开销。
  * 如果你使用太多的内联函数，那么二进制可执行文件的大小会很大，因为相同的代码重复。
  * 过多的内联也会降低指令缓存命中率，从而降低从缓存内存到主内存的指令获取速度。
  * 如果有人更改内联函数内的代码，内联函数可能会增加编译时间开销，那么所有调用位置都必须重新编译，因为编译器需要再次替换所有代码，否则它将继续使用旧功能.
  * 内联函数可能会导致抖动，因为内联可能会增加二进制可执行文件的大小。内存抖动会导致计算机性能下降。

3. `inline` 函数的使用场景：
   内联函数一般只适用于比较短小，处理较为简单的函数。内联只是对编译器的请求，而不是命令。编译器可以忽略内联请求。编译器可能不会在以下情况下执行内联：

* 如果函数包含循环（`for, while, do-while`）；
* 如果一个函数包含静态变量；
* 如果一个函数是递归的；
* 如果函数返回类型不是 `void`，并且函数体中不存在 `return` 语句；
* 如果函数包含 `switch` 或 `goto` 语句；

4. 内联可以去除函数只能定义一次的限制：
   内联函数可以在程序中定义不止一次， 但是 `inline` 函数的定义在某个源文件中只能出现一次，而且在所有源文件中，其定义必须是完全相同的。一般情况下，我们可以在头文件中定义 `inline` 函数，所有 `include` 该头文件，如果修改了头文件中的 `inline` 函数时，使用了该头文件的所有源文件都必须重新编译。比如我们可以在定义以下两个文件包含相同的函数。

```
// b.cpp
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

inline int min(int a, int b) {
    return a + b;
}

// a.cpp
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

inline int min(int a, int b) {
    return a + b;
}

int main() {
    int a = 10, b = 9;
    min(a, b);
    return 0;
}


```

参考资料：

* [Inline Functions in C++](https://leetcode.cn/link/?target=https://www.***.org/inline-functions-cpp/?ref=gcse)
* [Inline function](https://leetcode.cn/link/?target=https://en.wikipedia.org/wiki/Inline_function)

#### 19. class 和 struct 的异同 3

面试高频指数：★★★☆☆

`C++` 中为了兼容 `C` 语言而保留了 `C` 语言的 `struct` 关键字，并且加以扩充。在 `C` 语言中，`struct` 只能包含成员变量，不能包含成员函数。而在 `C++` 中，`struct` 类似于 `class`，既可以包含成员变量，又可以包含成员函数。
`C++` 中的 `struct` 和 `class` 基本是通用的，唯有几个细节不同：

* `class` 中类中的成员默认都是 `private` 属性的；而在 `struct` 中结构体中的成员默认都是 `public` 属性的。
* `class` 继承默认是 `private` 继承，而 `struct` 继承默认是 `public` 继承。
* `class` 可以用于定义模板参数，`struct` 不能用于定义模板参数。

```
struct A{}；
class B : A{}; // private 继承 
struct C : B{}； // public 继承
```

举例：

```
#include<iostream>

using namespace std;

class A{
public:
    void funA(){
        cout << "class A" << endl;
    }
};

struct B: A{ // 由于 B 是 struct，A 的默认继承级别为 public
public:
    void funB(){
        cout << "class B" << endl;
    }
};

class C: B{ // 由于 C 是 class，B 的默认继承级别为 private，所以无法访问基类 B 中的 printB 函数

};

int main(){
    A ex1;
    ex1.funA(); // class A

    B ex2;
    ex2.funA(); // class A
    ex2.funB(); // class B

    C ex3;
    ex3.funB(); // error: 'B' is not an accessible base of 'C'.
    return 0;
}

```

参考资料：

* [Inline Functions in C++](https://leetcode.cn/link/?target=https://www.ibm.com/docs/en/zos/2.3.0?topic=only-classes-structures-c)
* [Difference between Structure and Class in C++](https://leetcode.cn/link/?target=https://www.javatpoint.com/structure-vs-class-in-cpp)

#### 20. 返回函数中静态变量的地址会发生什么 3

面试高频指数：★★★☆☆

```
#include <iostream>
using namespace std;

int * fun(int tmp){
    static int var = 10;
    var *= tmp;
    return &var;
}

int main() {
    cout << *fun(5) << endl;
    return 0;
}

/*
运行结果：
50
*/

```

* 前面的章节中讲过，静态局部变量存在静态区，程序初始化时则已经创建了改变量，变量的生存周期为整个程序的生命周期。上述代码中在函数 `fun` 中定义了静态局部变量 `var`，使得离开该函数的作用域后，该变量不会销毁，返回到主函数中，该变量依然存在，从而使程序得到正确的运行结果，该静态局部变量直到程序运行结束后才销毁。
* 需要注意的是，全局静态对象在程序初始化时，则进行了初始化。局部静态对象的初始化在第一次进入函数内部时，才会调用对象的构造函数进行初始化。程序退出时，先释放静态局部变量，再释放全局静态变量。

参考资料：

* [线程安全：局部静态变量的初始化](https://leetcode.cn/link/?target=https://baijiahao.baidu.com/s?id=1686962192046161801&wfr=spider&for=pc)
* [static初始化](https://leetcode.cn/link/?target=https://zhuanlan.zhihu.com/p/406301228)

#### 21. sizeof(1==1) 在 C 和 C++ 中的结果 3

面试高频指数：★★★☆☆

前面的章节中讲述过 `sizeof` 接受的参数可以是对象也可以是表达式，但是 `sizeof(expression)` 在运行时不会对接受的表达式进行计算，编译器只会推导表达式的类型从而计算占用的字节大小；

```
#include <iostream>
using namespace std;
int main(int argc, char * argv[])
{
    int x = 4;
    sizeof(x++);
    printf("%d\n", x);
    return 0;
}

```

* 由于 `C` 语言没有 `bool` 类型，用整形表示布尔型，因此下面的程序返回 `4`;

```
#include<stdio.h>

void main(){
    printf("%d\n", sizeof(1==1));
}

/*
运行结果：
4
*/

```

* 由于 `C++` 语言有 `bool` 类型，布尔型占 `1` 个字节，因此下面的程序返回 `1`;

```
#include <iostream>
using namespace std;

int main() {
    cout << sizeof(1==1) << endl;
    return 0;
}

/*
1
*/

```

参考资料：

* [sizeof operator in C](https://leetcode.cn/link/?target=https://www.***.org/sizeof-operator-c/)

#### 22. memmove 函数的底层原理 3

面试高频指数：★★★☆☆

* `memmove` 用于拷贝字节，如果目标区域和源区域有重叠的话，`memmove` 能够保证源串在被覆盖之前将重叠区域的字节拷贝到目标区域中，但复制后源内容会被更改。但是当目标区域与源区域没有重叠则和 `memcpy` 函数功能相同。面试时会经常要求实现 `memmove` 函数，在实现的时候需要特殊处理地址重叠的情况。

```
void *memmove(void *dst, const void *src, size_t size)
{
    char *psrc;
    char *pdst;

    if (NULL == dst || NULL == src)
    {
        return NULL;
    }

    if ((src < dst) && (char *)src + size > (char *)dst) // 出现地址重叠的情况，自后向前拷贝
    {
        psrc = (char *)src + size - 1;
        pdst = (char *)dst + size - 1;
        while (size--)
        {
            *pdst-- = *psrc--;
        }
    }
    else
    {
        psrc = (char *)src;
        pdst = (char *)dst;
        while (size--)
        {
            *pdst++ = *psrc++;
        }
    }

    return dst;
}

```

参考资料：

* [memmove() in C/C++](https://leetcode.cn/link/?target=https://www.***.org/memmove-in-cc/?ref=gcse)

#### 23. new 的作用 2

面试高频指数：★★☆☆☆

1. `new` 的简介：
   `new` 是 `C++` 中的关键字，尝试分配和初始化指定或占位符类型的对象或对象数组，并返回指向对象 (或数组的初始对象) 的指针。

* 用 `new` 创建对象时，首先从堆中申请相应的内存空间，然后调用对象的构造函数，最后返回指向对象的指针。`new` 操作符从自由存储区（`free store`）上为对象动态分配内存空间，而 `malloc` 函数从堆上动态分配内存。自由存储区是 `C++` 基于 `new` 操作符的一个抽象概念，凡是通过 `new` 操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，`C` 语言使用 `malloc` 从堆上分配内存，使用 `free` 释放已分配的对应内存。`new` 可以指定在内存地址空间创建对象，用法如下:

```
new (place_address) type
```

`place_address` 为一个指针，代表一块内存的地址。当使用上面这种仅以一个地址调用 `new` 操作符时，`new` 操作符调用特殊的 `operator new`：

```
void * operator new (size_t, void *) 
```

对于指定的地址的 `new` 对象，在释放时，不能直接调用 `delete`, 应该先调用对象的析构函数，然后再对内存进行释放。比如以下程序:

```
include <iostream>
using namespace std;

int main(int argc, char* argv[])
{
    char buf[100];
    int *p=new (buf) int(101);
    cout<<*(int*)buf<<endl;
    return 0;
}

```

* `new` 可以用来动态生成对象数组，但此时 `new` 生成的数组，只能用 `delete` 来释放。

```
int *arr = new int [100];
```

* 在 `cpp` 中由于 `new` 作为操作符可以进行重载，所以可以对 `new` 进行重载，比如可以指定构造函数对对象进行初始化。对 `new` 操作符可以进行全局重载和局部重载，全局重载后，所有调用 `new` 的操作都会被重写；局部重载就是在类中重写 `operator new` 函数，但只会对该类生效，即该类执行 `new` 操作时会生效。

```
#include <iostream>

class Test {
private:
    int value;

public:
    Test() {
        printf("[Test] Constructor\n");
    }

    void* operator new(size_t size) {
        printf("[Test] operator new\n");
        return NULL;
    }
};

int main() 
{ 
    Test* t = new Test();
    return 0;
}

// [Test] operator new
// [Test] Constructor

```

参考资料：

* [new (C++)](https://leetcode.cn/link/?target=https://zh.m.wikipedia.org/zh/New_(C%2B%2B))
* [C++ new的三种面貌](https://leetcode.cn/link/?target=https://cloud.tencent.com/developer/article/1177460)
* [new 运算符 (C++)](https://leetcode.cn/link/?target=https://docs.microsoft.com/zh-cn/cpp/cpp/new-operator-cpp?view=msvc-170)

* 在日常使用时一般情况下建议声明 `explicit` 的构造函数，从而可以阻止编译器执行非预期 (往往也不被期望) 的类型转换，因为某些非预期的类型转换可能会引起意向不到的错误。

参考资料：

* [C++ explicit 关键字](https://leetcode.cn/link/?target=https://zhuanlan.zhihu.com/p/52152355)
* [What does the explicit keyword mean?](https://leetcode.cn/link/?target=https://stackoverflow.com/questions/121162/what-does-the-explicit-keyword-mean)
* [explicit specifier](https://leetcode.cn/link/?target=https://en.cppreference.com/w/cpp/language/explicit)

[](https://leetcode.cn/leetbook/read/cmian-shi-tu-po/vwegz6/)

* 在日常使用时一般情况下建议声明 `explicit` 的构造函数，从而可以阻止编译器执行非预期 (往往也不被期望) 的类型转换，因为某些非预期的类型转换可能会引起意向不到的错误。

参考资料：

* [C++ explicit 关键字](https://leetcode.cn/link/?target=https://zhuanlan.zhihu.com/p/52152355)
* [What does the explicit keyword mean?](https://leetcode.cn/link/?target=https://stackoverflow.com/questions/121162/what-does-the-explicit-keyword-mean)
* [explicit specifier](https://leetcode.cn/link/?target=https://en.cppreference.com/w/cpp/language/explicit)

[](https://leetcode.cn/leetbook/read/cmian-shi-tu-po/vwegz6/)
