### 3, C++ 关键字与关键库函数

本章将重点涉及以下高频知识点：

1. [sizeof 和 strlen 的区别](https://leetcode.cn/leetbook/read/cmian-shi-tu-po/vw9445/)
2. [C 和 C++ static 中的作用](https://leetcode.cn/leetbook/read/cmian-shi-tu-po/vwrt6c/)
3. [const 作用及用法](https://leetcode.cn/leetbook/read/cmian-shi-tu-po/vwplqi/)
4. [define 和 const 的区别](https://leetcode.cn/leetbook/read/cmian-shi-tu-po/vwmd3e/)
5. [inline 作用及使用方法](https://leetcode.cn/leetbook/read/cmian-shi-tu-po/vwnolj/)
6. [new 和 malloc 的区别](https://leetcode.cn/leetbook/read/cmian-shi-tu-po/vwd4vd/)
7. [delete 与 free 的区别](https://leetcode.cn/leetbook/read/cmian-shi-tu-po/vw0gnh/)
8. [volatile 的作用与使用场景](https://leetcode.cn/leetbook/read/cmian-shi-tu-po/vwudo7/)
9. [用宏实现比较大小，以及两个数中的最小值](https://leetcode.cn/leetbook/read/cmian-shi-tu-po/vw2muv/)
10. [宏定义（define）和内联函数（inline）的区别](https://leetcode.cn/leetbook/read/cmian-shi-tu-po/vwvf0r/)
11. [C 和 C++ struct 的区别](https://leetcode.cn/leetbook/read/cmian-shi-tu-po/vw7qa3/)[struct 和 union 的区别](https://leetcode.cn/leetbook/read/cmian-shi-tu-po/vwltmm/)
12. [extern C 的作用](https://leetcode.cn/leetbook/read/cmian-shi-tu-po/vw8m56/)
13. [strcpy 函数的缺陷](https://leetcode.cn/leetbook/read/cmian-shi-tu-po/vwqjji/)
14. [lambda 表达式的应用](https://leetcode.cn/leetbook/read/cmian-shi-tu-po/vwegz6/)
15. [explicit 的作用](https://leetcode.cn/leetbook/read/cmian-shi-tu-po/vwoqg2/)
16. [define 和 typedef 的区别](https://leetcode.cn/leetbook/read/cmian-shi-tu-po/vwantg/)
17. [inline 函数工作原理](https://leetcode.cn/leetbook/read/cmian-shi-tu-po/vwv57t/)
18. [class 和 struct 的异同](https://leetcode.cn/leetbook/read/cmian-shi-tu-po/vwilr1/)
19. [返回函数中静态变量的地址会发生什么](https://leetcode.cn/leetbook/read/cmian-shi-tu-po/vwtne5/)
20. [sizeof(1==1) 在 C 和 C++ 中的结果](https://leetcode.cn/leetbook/read/cmian-shi-tu-po/vw3ox2/)
21. [memmove 函数的底层原理](https://leetcode.cn/leetbook/read/cmian-shi-tu-po/vwqxfc/)
22. [auto 类型推导的原理](https://leetcode.cn/leetbook/read/cmian-shi-tu-po/vw6ybe/)
23. [new 的作用](https://leetcode.cn/leetbook/read/cmian-shi-tu-po/vwwcws/)

#### 01. sizeof 和 strlen 的区别 5

面试高频指数：★★★★★

* `strlen` 是头文件 `<cstring>` 中的函数，`sizeof` 是 `C++` 中的运算符。`strlen` 测量的是字符串的实际长度（其源代码如下），以 `\0` 结束，而 `sizeof` 测量的是对象或者表达式类型占用的字节大小。`strlen` 源代码如下:

```
size_t strlen(const char *str) {
    size_t length = 0;
    while (*str++)
        ++length;
    return length;
}

```

举例：

```
#include <iostream>
#include <cstring>

using namespace std;

int main()
{
    char arr[10] = "hello";
    cout << strlen(arr) << endl; // 5
    cout << sizeof(arr) << endl; // 10
    return 0;
}

```

若字符数组 `arr` 作为函数的形参，`sizeof(arr)` 中 `arr` 被当作字符指针来处理，`strlen(arr)` 中 `arr` 依然是字符数组，从下述程序的运行结果中就可以看出。

```
#include <iostream>
#include <cstring>

using namespace std;

void size_of(char arr[])
{
    cout << sizeof(arr) << endl; // warning: 'sizeof' on array function parameter 'arr' will return size of 'char*' .
    cout << strlen(arr) << endl; 
}

int main()
{
    char arr[20] = "hello";
    size_of(arr); 
    return 0;
}
/*
输出结果：
8
5
*/

```

二者的不同之处:

* `strlen` 本身是库函数，因此在程序运行过程中，计算长度；而 `sizeof` 是在编译时计算长度；`sizeof` 的参数可以是类型，也可以是变量，且必须是完整类型；`strlen` 的参数必须是 `char *` 类型的变量。
* `sizeof` 接受的参数可以是对象也可以是表达式，但是 `sizeof(expression)` 在运行时不会对接受的表达式进行计算，编译器只会推导表达式的类型从而计算占用的字节大小；而 `strlen` 是一个函数，如果接受表达式则会对表达式进行运算。

```
  #include <iostream>
  using namespace std;
  int main(int argc, char * argv[])
  {
      int x = 4;
      char *s = "12345678";
      char *p = s;
      sizeof(x++);
      printf("%d\n", x);
      strlen(p++);
      return 0;
  }

```

* 对于 `C99` 中结构体允许最后一个变量为不定长数组，`sizeof` 则不计算空间。

```
  #include <iostream>
  #include <cstring>

  using namespace std;

  struct flexarray {
      int val;
      int array[];  /* Flexible array member; must be last element of struct */
  };

  int main()
  {
      printf("%ld\n", sizeof(struct flexarray)); // 4
  }

```

参考资料：

* [sizeof](https://leetcode.cn/link/?target=https://en.wikipedia.org/wiki/Sizeof)
* [sizeof operator in C](https://leetcode.cn/link/?target=https://www.geeksforgeeks.org/sizeof-operator-c/)
* [sizeof operator](https://leetcode.cn/link/?target=https://en.cppreference.com/w/cpp/language/sizeof)


#### 02. C 和 C++ static 中的作用 5

面试高频指数：★★★★★

* 在 `C` 语言中，使用 `static` 可以定义局部静态变量、外部静态变量、静态函数。
* 在 `C++` 中，使用 `static` 可以定义局部静态变量、外部静态变量、静态函数、静态成员变量和静态成员函数。因为 `C++` 中有类的概念，静态成员变量、静态成员函数都是与类有关的概念。

1. `static` 全局静态变量:

* 普通全局变量和 `static` 全局静态变量都为静态存储方式。普通全局变量的作用域是整个源程序，当一个源程序由多个源文件组成时，普通全局变量在各个源文件中都是有效的；
* 静态全局变量则限制了其作用域，即只在定义该变量的源文件内有效，在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其他源文件中引起错误。静态全局变量只初始化一次，防止在其他文件中使用。实际上全局静态变量存储在内存的静态存储区，生命周期贯穿于整个程序运行期间。静态变量会被放在程序的静态数据存储区，这样可以在下一次调用的时候还可以保持原来的赋值，静态变量用 `static` 告知编译器，自己仅仅在变量的作用范围内可见，实际是依靠编译器来控制作用域。

2. `static` 局部静态变量:
   局部静态变量只能被初始化一次。与全局静态变量不同的是静态局部变量的作用域仅限于函数内部，它的作用域与函数内部的局部变量相同。实际上局部静态变量同样也存储在静态存储区，因此它的生命周期贯穿于整个程序运行期间。

a.cpp:

```
#include <iostream>
using namespace std;
int g_var = 0; // 全局变量
static char *gs_var;  // 静态全局变量

int main()
{
    int var;                    // 局部变量
    static int s_var = 0;       // 静态局部变量
    return 0;
}

```

* `b.cpp`

```
#include <iostream>
using namespace std;
extern int g_var = 0; // 访问全局变量
// extern static char *gs_var;  无法访问静态全局变量

int test()
{
    g_var = 1;
}

```

3. `static` 静态函数:
   `static` 函数限制函数的作用域，仅可在定义该函数的文件内部调用，如下所示程序示例编译会报错，找不到 `test` 函数定义。

* `a.cpp`:

```
#include <iostream>
using namespace std;
int g_var = 0; // 全局变量
static char *gs_var;  // 静态全局变量
extern int test();
int main()
{
    int var;                    // 局部变量
    static int s_var = 0;       // 静态局部变量
    test();  
    return 0;
}

```

* `b.cpp`

```
#include <iostream>
using namespace std;

static int test()
{
    return 0；
}
```

4. `static` 静态成员变量:

* 静态成员变量是在类内进行声明，在类外进行定义和初始化，在类外进行定义和初始化的时候不要出现 `static` 关键字和 `private`、`public`、`protected` 访问规则。
* 静态成员变量相当于类域中的全局变量，被类的所有对象所共享，包括派生类的对象，且只能该变量只能被初始化一次，不能在类的构造函数中对静态成员变量进行初始化。

```
// C++ program to demonstrate static
// variables inside a class
#include<iostream>
using namespace std;

class GfG
{
public:
	static int i;
	GfG() {

	};
};

int GfG::i = 1; // initial

int main()
{
    GfG obj1;
    GfG obj2;
    obj1.i =2; // error
    obj2.i = 3; // error
    GfG::i = 10; // assignment
    // prints value of i
    cout << obj1.i<<" "<<obj2.i; // 10 
}


```

* 静态成员变量可以作为成员函数的参数，而普通成员变量不可以。

```
#include <iostream>
using namespace std;

class A
{
public:
    static int s_var;
    int var;
    void fun1(int i = s_var); // 正确，静态成员变量可以作为成员函数的参数
    void fun2(int i = var);   //  error: invalid use of non-static data member 'A::var'
};
int main()
{
    return 0;
}

```

* 静态数据成员的类型可以是所属类的类型，而普通数据成员的类型只能是该类类型的指针或引用。

```
#include <iostream>
using namespace std;

class A
{
public:
    static A s_var; // 正确，静态数据成员
    A var;          // error: field 'var' has incomplete type 'A'
    A *p;           // 正确，指针
    A &var1;        // 正确，引用
};

int main()
{
    return 0;
}


```

5. `static` 静态成员函数:
   静态成员函数不能调用非静态成员变量或者非静态成员函数，因为静态成员函数没有 `this` 指针。静态成员函数做为类作用域的全局函数。
   静态成员函数不能声明成虚函数（`virtual`）、`const` 函数和 `volatile` 函数。

```
#include<iostream>
using namespace std;
class GfG
{
public:
	static void printMsg()
	{
		cout<<"Welcome to GfG!";
	}
};
int main()
{
	GfG::printMsg();
}

```

6. `static` 对象:
   静态对象的生存周期为整个程序的生命周期，而非静态对象的生命周期只存在于某个循环中，我们可以通过以下程序做对比:

```
#include<iostream>
using namespace std;

class GfG1
{
	int i;
	public:
		GfG1()
		{
			i = 0;
			cout << "GFG1 Inside Constructor\n";
		}
		~GfG1()
		{
			cout << "GFG1 Inside Destructor\n";
		}
};

class GfG2
{
	int i;
	public:
		GfG2()
		{
			i = 0;
			cout << "GfG2 Inside Constructor\n";
		}
		~GfG2()
		{
			cout << "GfG2 Inside Destructor\n";
		}
};

int main()
{
	int x = 0;
	if (x==0)
	{
		GfG1 obj1;
        static GfG2 obj2;
	}
	cout << "End of main\n";
}

```

程序的输出为:

```
GFG1 Inside Constructor
GfG2 Inside Constructor
GFG1 Inside Destructor
End of main
GfG2 Inside Destructor

```

我们可以观察到当 `main` 函数执行完成，静态对象 `obj2` 对象的生命周期仍然存在。

参考资料：

* [Static Keyword in C++](https://leetcode.cn/link/?target=https://www.***.org/static-keyword-cpp/)
* [static members](https://leetcode.cn/link/?target=https://en.cppreference.com/w/cpp/language/static)
* [C/C++ 中 static 的用法全局变量与局部变量](https://leetcode.cn/link/?target=https://www.runoob.com/w3cnote/cpp-static-usage.html)
* [The static keyword and its various uses in C++](https://leetcode.cn/link/?target=https://stackoverflow.com/questions/15235526/the-static-keyword-and-its-various-uses-in-c)
* [Static Members of a C++ Class](https://leetcode.cn/link/?target=https://www.tutorialspoint.com/cplusplus/cpp_static_members.htm)

#### 03. const 作用及用法 5

面试高频指数：★★★★★

* `const` 修饰普通变量或者成员变量，定义成 `const` 常量，相较于宏常量可进行类型检查，节省内存空间，提高了效率。
* `const` 修饰函数参数，使得传递过来的函数参数的值不能改变。
* `const` 修饰成员函数，使得成员函数不能修改任何类型的成员变量（`mutable` 修饰的变量除外），也不能调用非 `const` 成员函数，因为非 `const` 成员函数可能会修改成员变量。

1. `const` 变量:
   定义成 `const` 常量，相较于宏常量，可进行类型检查，节省内存空间，提高了效率。被定义为 `const` 的变量是不可修改的。

```
#include <iostream>
using namespace std;

int main()
{
    const int y = 10;
    cout << y;
    y = 9; // error
    return 0;
}


```

2. `const` 指针:

* `const` 修饰指针指向的内容，则指针指向的内容不可变，但是指针本身的内容可以改变。

```
int x = 0;
int *q = &x;
const int *p = &x;
*p = 10; // error
p = q; // OK
```

* `const` 修饰指针，则指针为不可变量，指针指向的内容可以变，但指针本身不能变。

  ```
  int a = 8;
  int* const p = &a; // 指针为常量
  *p = 9;  // OK
  int  b = 7;
  p = &b; // error

  ```
* `const` 修饰指针和指针指向的内容，则指针和指针指向的内容都为不可变量。

  ```
  int a = 8;
  const int * const  p = &a;
  ```


3. `const` 引用:
   `const` 引用是指向 `const` 对象的引用，可以读取变量，但不能通过引用修改指向的对象。我们可以将 `const` 引用指向非 `const` 变量，但不能使用非 `const` 引用指向 `const` 变量。`const` 引用可以初始化为不同类型的对象或者右值（如字面值常量），但非 `const` 引用不可以。

```
int i = 10;
const int &ref = i;
double d = 3.14;
const int &ref2 = d;
```

4. `const` 成员变量：
   `const` 成员变量只能在类内声明、定义，在构造函数初始化列表中初始化。
   `const` 成员变量只在某个对象的生存周期内是常量，对于整个类而言却是可变的，因为类可以创建多个对象，不同类的 `const` 成员变量的值是不同的。因此不能在类的声明中初始化 `const` 成员变量。
5. `const` 函数参数与返回值:
   用 `const` 修饰函数参数，表明函数参数为常量，在函数内部不可以修改参数的内容，一般我们使用 `const` 指针或者 `const` 引用。函数返回值如果为指针或者引用，我们可以用 `const` 指针或者引用接受返回值，此时指向的内容则不可以修改。
6. `const` 成员函数：
   不能修改成员变量的值，除非有 `mutable` 修饰；只能访问成员变量。
   不能调用非常量成员函数，以防修改成员变量的值。

* `const` 对象只能访问 `const` 成员函数,而非 `const` 对象可以访问任意的成员函数，包括 `const` 成员函数。
* 加上 `mutable` 修饰符的数据成员,对于任何情况下通过任何手段都可修改,自然此时的 `const` 成员函数是可以修改它的。

```
#include <iostream>
using namespace std;
class A
{
public:
	int var;
	A(int tmp) : var(tmp) {}
	void c_fun(int tmp) const // const 成员函数
	{
		var = tmp; // error: assignment of member 'A::var' in read-only object. 在 const 成员函数中，不能修改任何类成员变量。
		fun(tmp); // error: passing 'const A' as 'this' argument discards qualifiers. const 成员函数不能调用非 const 成员函数，因为非 const 成员函数可能会修改成员变量。
	}

	void fun(int tmp)
	{
		var = tmp;
	}
};
int main()
{
    return 0;
}

```

参考资料：

* [C++ const 关键字小结](https://leetcode.cn/link/?target=https://www.runoob.com/w3cnote/cpp-const-keyword.html)
* [const (C++)](https://leetcode.cn/link/?target=https://docs.microsoft.com/en-us/cpp/cpp/const-cpp?view=msvc-170)
* [Const keyword in C++](https://leetcode.cn/link/?target=https://www.geeksforgeeks.org/const-keyword-in-cpp/)



#### 04. define 和 const 的区别 5

面试高频指数：★★★★★

二者之间的区别:

* 编译阶段：`define` 是在编译预处理阶段进行替换，`const` 是在编译阶段确定其值。
* 安全性：`define` 定义的宏常量没有数据类型，只是进行简单的代码替换，不会进行类型安全的检查；`const` 定义的常量是有类型的，是要进行判断的，可以避免一些低级的错误。
* 存储空间：`define` 定义的宏定义只是作为代码替换的表达式而已，宏定义本身不占用内存空间，`define` 定义的宏常量，在程序中使用多少次就会进行多少次替换，内存中有多个备份，实际使用宏定义替换代码时占用的是代码段的空间；`const` 定义的常量占用静态存储区的只读空间，程序运行过程中常量只有一份。
* 调试：`define` 定义的宏常量不能调试，因为在预编译阶段就已经进行替换了；`const` 定义的常量可以进行调试。
* `define` 可以接受参数构造非常复杂的表达式，`const` 不能接受参数。

参考资料：

* [Difference between #define and const in C?](https://leetcode.cn/link/?target=https://www.***.org/diffference-define-const-c/)
* [What is the difference between #define and const?](https://leetcode.cn/link/?target=https://stackoverflow.com/questions/6442328/what-is-the-difference-between-define-and-const)
* [Difference between const and #define in C, C++ programming language](https://leetcode.cn/link/?target=https://www.includehelp.com/cpp-tutorial/difference-between-const-and-define.aspx)


#### 05. new 和 malloc 的区别 5

面试高频指数：★★★★★

`malloc` 的实现原理：

`malloc` 为 `C` 语言的库函数，主要用来从堆中申请指定大小且连续的内存空间。实际的底层实现可能较为复杂，每个程序都带有自己的动态内存管理子模块，常见的动态内存分配算法有 `best fit` 和 `first fit` 等。由于现代操作系统用户程序都是采用虚拟地址空间，理论上对于一个程序来说，在 `64` 位地址空间下，它可见的地址空间为 `0x0000000000000000-0xFFFFFFFFFFFFFFF`，而程序中的 `heap` 段是虚拟地址中的一段连续的空间。程序运行时，操作系统会预先为程序分配 `heap` 段，虽然程序的运行，使用的 `heap` 空间不断增大，当操作系统已分配的空间不够使用时，这时会通过 `mmap` 映射新的物理内存页加入到 `heap` 空间中，并将新加入的物理页映射到 `heap` 的末尾，从而形成连续的虚拟内存空间。

1. `new` 与 `malloc` 的区别：

* `new` 在申请内存的同时，会调用对象的构造函数，对象会进行初始化，`malloc` 仅仅在堆中申请一块指定大小的内存空间，并不会对内存和对象进行初始化。
* `new` 可以指定内存空间初始化对象，而 `malloc` 只能从堆中申请内存。
* `new` 是 `c++` 中的一个操作符，而 `malloc` 是 `C` 中的一个函数。
* `new` 的返回值为一个对象的指针类型，而 `malloc` 统一返回 `void *` 指针。
* `new` 内存分配成功，返回该对象类型的指针，分配失败，抛出 `bad_alloc` 异常；而 `malloc` 成功申请到内存，返回指向该内存的指针；分配失败，返回 `NULL` 指针。
* `new` 的空间大小由编译器会自动计算，而 `malloc` 则需要指定空间大小。
* `new` 作为一个运算符可以进行重载，而 `malloc` 作为一个函数不支持重载。
* `malloc` 可以更改申请过的空间大小，我们可以 `realloc` 指定空间大小，而 `new` 一旦申请则无法更改。

参考资料：

* [malloc](https://leetcode.cn/link/?target=https://en.cppreference.com/w/c/memory/malloc)
* [C library function - malloc()](https://leetcode.cn/link/?target=https://www.tutorialspoint.com/c_standard_library/c_function_malloc.htm)
* [Dynamic Memory Allocation in C using malloc(), calloc(), free() and realloc()](https://leetcode.cn/link/?target=https://www.***.org/dynamic-memory-allocation-in-c-using-malloc-calloc-free-and-realloc/)
* [Difference Between malloc() and calloc() with Examples](https://leetcode.cn/link/?target=https://www.***.org/difference-between-malloc-and-calloc-with-examples/)


#### 06. delete 与 free 的区别 5

面试高频指数：★★★★★

`1. free` 的简介：

`free` 释放 `heap` 中申请的动态内存空间，只能释放 `malloc`，`calloc`，`realloc` 申请的内存。需要注意的是，`free` 函数只是将参数指针指向的内存归还给操作系统，并不会把参数指针置 `NULL`，为了以后访问到被操作系统重新分配后的错误数据，所以在调用 `free` 之后，通常需要手动将指针置 `NULL`。内存资源都是由操作系统来管理的，而不是编译器，编译器只是向操作系统提出申请，所以 `free` 函数是没有能力去真正的 `free` 内存的，只是向内存管理模块归还了内存，其他模块还可以继续申请使用这些内存。`free` 后指针仍然指向原来的堆地址，实际还可以使用，但操作系统可能将这块内存已经分配给其他模块使用，一般建议在 `free` 以后将指针置为空。一个指针经过两次 `free`，也是比较危险的操作，因为可能该段内存已被别的内存使用申请使用了，`free` 之后会造成严重后果。

1. `delete` 的简介：

   `delete` 是 `C++` 中的一个操作符，如果对象存在析构函数，它首先执行该对象所属类的析构函数，进而通过调用 `operator delete` 的标准库函数来释放所占的内存空间。`delete` 用来释放单个对象所占的空间，只会调用一次析构函数；`delete []` 用来释放数组空间，会对数组中的每个元素都调用一次析构函数。`delete` 只能用来释放 `new` 操作返回的指针，否则会产生不可预知的后果。在单个对象上的删除 使用 `delete []` 的数组形式，以及对数组使用非数组形式的删除都会产生不可预知的后果。如果 `new` 的对象是指定地址，则不能直接调用 `delete`。
2. `delete` 与 `free` 的区别：

* `delete` 是 `C++` 中的一个操作符，可以进行重载；而 `free` 是 `C` 中的一个函数，不能进行重载；
* `free` 只会释放指向的内存，不会执行对象的析构函数；`delete` 则可以执行对象的析构函数；


参考资料：

* [Difference between delete and free() in C++](https://leetcode.cn/link/?target=https://www.includehelp.com/cpp-tutorial/difference-between-delete-and-free.aspx)


#### 07. volatile 的作用与使用场景 5

面试高频指数：★★★★★


1. `volatile` 的简介：
   `volatile` 的作用：当对象的值可能在程序的控制或检测之外被改变时，应该将该对象声明为 `volatile`，告知编译器不应对这样的对象进行优化。`volatile` 关键字修饰变量后，提醒编译器它后面所定义的变量随时都有可能改变，因此编译后的程序每次需要存储或读取这个变量的时候，都会直接从变量地址中读取数据。如果没有 `volatile` 关键字，则编译器可能优化读取和存储，可能暂时使用寄存器中的值，如果这个变量由别的程序更新了的话，将出现不一致的现象。
   使用 `volatile` 关键字试图阻止编译器过度优化，`volatile` 主要作用如下：

* 阻止编译器为了提高速度将一个变量缓存到寄存器内而不写回；（缓存一致性协议、轻量级同步）
* 阻止编译器调整操作 `volatile` 变量的指令排序。

2. `volatile` 的作用：

* 读取变量时，阻止编译器对缓存的优化: `volatile` 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。比如声明时 `volatile` 变量，`int volatile vInt`; 当要求使用 `volatile` 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据，而且读取的数据立刻被保存。

```
volatile int i=10;
int a = i;
...
// 其他代码，并未明确告诉编译器，对 i 进行过操作
int b = i;
```

`volatile` 修饰 `i` 后，表明每次使用 `i` 时必须从 `i` 的地址中读取，因而编译器生成的汇编代码会重新从 `i` 的地址读取数据放在 `b` 中。如果不加 `volatile`，编译器会进行优化，编译器发现两次从 `i` 读数据的代码之间的代码没有对 `i` 进行过操作，它会自动把上次读的数据放在 `b` 中，而不是重新从 `i` 里面读，如果 `i` 是一个寄存器变量，则 `i` 可能已经被外部程序进行改写，因此 `volatile`可以保证对特殊地址的稳定访问。

* 写入变量时，阻止编译器对指令顺序的优化: 在某些特定的场景下，比如读写寄存器或者操作某些硬件，需要按照某些特定的指令序列读写寄存器，而不能忽略其中的某些步骤，比如如下程序:

```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    int ra = 0;
    int rb = 0;
    ra = 0x1111;
    ra = 0x2222;
    ra = 0x3333;
    rb = ra;
    printf("%d\n", ra);
    return 0;
}

```

我们使用编译器优化：

g++ -S -O3 test.cpp -o test

查看编译后的代码为:

```
0000000000000560 <main>:
 560:   48 83 ec 08             sub    $0x8,%rsp
 564:   ba 33 33 00 00          mov    $0x3333,%edx
 569:   bf 01 00 00 00          mov    $0x1,%edi
 56e:   31 c0                   xor    %eax,%eax
 570:   48 8d 35 8d 01 00 00    lea    0x18d(%rip),%rsi        # 704 <_IO_stdin_used+0x4>
 577:   e8 c4 ff ff ff          callq  540 <__printf_chk@plt>
 57c:   31 c0                   xor    %eax,%eax
 57e:   48 83 c4 08             add    $0x8,%rsp
 582:   c3                      retq
 583:   66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
 58a:   00 00 00
 58d:   0f 1f 00                nopl   (%rax)

```

我们可以看到编译的汇编代码，变量 `ra` 直接赋值为 `0x3333`，从而省略了中间赋值过程：

```
ra = 0x1111;
ra = 0x2222;
ra = 0x3333;
```

在初始化某些硬件平台时，我们需要按照芯片手册对寄存器依次连续写入一系列的指令，上述程序中假如 `ra` 为一个寄存器变量，则依次为寄存器按照顺序写入特定的值来操作硬件。如果不添加 `volatile` 关键字，某些编译器会对上述代码进行优化，直接会省略中间的写入指令。实际在硬件在初始化中不能省略中间的指令，此时编译器的优化反而造成错误，此时我们用 `volatile` 修饰变量 `ra`，可以阻止编译器对指令顺序进行优化。

```
0000000000000560 <main>:
 560:   48 83 ec 18             sub    $0x18,%rsp
 564:   48 8d 35 b9 01 00 00    lea    0x1b9(%rip),%rsi        # 724 <_IO_stdin_used+0x4>
 56b:   bf 01 00 00 00          mov    $0x1,%edi
 570:   c7 44 24 0c 00 00 00    movl   $0x0,0xc(%rsp)
 577:   00
 578:   c7 44 24 0c 11 11 00    movl   $0x1111,0xc(%rsp)
 57f:   00
 580:   c7 44 24 0c 22 22 00    movl   $0x2222,0xc(%rsp)
 587:   00
 588:   c7 44 24 0c 33 33 00    movl   $0x3333,0xc(%rsp)
 58f:   00
 590:   8b 44 24 0c             mov    0xc(%rsp),%eax
 594:   31 c0                   xor    %eax,%eax
 596:   8b 54 24 0c             mov    0xc(%rsp),%edx
 59a:   e8 a1 ff ff ff          callq  540 <__printf_chk@plt>
 59f:   31 c0                   xor    %eax,%eax
 5a1:   48 83 c4 18             add    $0x18,%rsp
 5a5:   c3                      retq
 5a6:   66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
 5ad:   00 00 00


```

3. `volatile` 的应用场景：
   在实际场景中除了操纵硬件需要用到 `volatile` 以外，更多的可能是多线程并发访问共享变量时，一个线程改变了变量的值，怎样让改变后的值对其它线程可见，此时我们就需要使用 `volatile` 进行修饰。一般说来，`volatile` 用在如下的几个地方：

* 中断服务程序中修改的供其它程序检测的变量需要加 `volatile`；
* 多任务环境下各任务间共享的标志应该加 `volatile`；
* 存储器映射的硬件寄存器通常也要加 `volatile` 说明，因为每次对它的读写都可能有不同意义；

参考资料：

* [volatile (C++)](https://leetcode.cn/link/?target=https://docs.microsoft.com/en-us/cpp/cpp/volatile-cpp?view=msvc-170)
* [What is volatile keyword in C++?](https://leetcode.cn/link/?target=https://www.tutorialspoint.com/what-is-volatile-keyword-in-cplusplus)
* [Why do we use volatile keyword?](https://leetcode.cn/link/?target=https://stackoverflow.com/questions/4437527/why-do-we-use-volatile-keyword)



#### 08. 用宏实现比较大小，以及两个数中的最小值 4

面试高频指数：★★★★☆

实现比较简单，需要注意括号和作用域的问题，由于 `#define` 只是做简单的替换，而 `#define` 中替代时可能含有表达式，因此我们需要用括号进行作用域限制。

```
#include <iostream>
#define MAX(X, Y) ((X) > (Y) ? (X) : (Y))
#define MIN(X, Y) ((X) < (Y) ? (X) : (Y))
using namespace std;

int main ()
{
    int var1 = 10, var2 = 100;
    cout << MAX(var1, var2) << endl;
    cout << MIN(var1, var2) << endl;
    return 0;
}
/*
程序运行结果：
100
10
*/

```

上述可能存在重复计算的问题，比如表达式 `X,Y` 均计算了两次，多次计算在某些场景下性能较低或者会产生影响，我们可以进行简化如下:

```
#define MIN(x, y) ({				\
	typeof(x) _min1 = (x);			\
	typeof(y) _min2 = (y);			\
	(void) (&_min1 == &_min2);		\
	_min1 < _min2 ? _min1 : _min2; })

#define MAX(x, y) ({				\
	typeof(x) _max1 = (x);			\
	typeof(y) _max2 = (y);			\
	(void) (&_max1 == &_max2);		\
	_max1 > _max2 ? _max1 : _max2; })

```

```
int x = 1, y = 2;
int z = MIN(x++, y); 
```

上述的宏定义展开为:

```
z = (x++) < y ? (x++) : y;
```

此时执行完成后 `x` 变为了 `3`，与我们设想的 `x` 只累加一次不符合，此时我们可以定义临时变量 `_min1` 等于表达式 `x` 的计算结果，这样即可有效防止表达式被计算多次。同时我们使用 `(void) (&_max1 == &_max2)` 来检测传入的两个参数类型是否相同，这样即可防止传入不同类型的元素进行比较，最终我们返回二者的比较结果即可。

参考资料：

* [【宏定义系列】 两个数中的最小](https://leetcode.cn/link/?target=https://blog.csdn.net/u012028275/article/details/118052249)


#### 09. 宏定义（define）和内联函数（inline）的区别 4

面试高频指数：★★★★☆

1. 二者的区别

* 内联函数是在编译时展开，而宏在编译预处理时展开；在编译的时候，内联函数直接被嵌入到目标代码中去，而宏只是一个简单的文本替换。
* 内联函数是真正的函数，和普通函数调用的方法一样，在调用点处直接展开，避免了函数的参数压栈操作，减少了调用的开销，在编译后的代码段中可以看到内联函数的定义。宏定义编写较为复杂，常需要增加一些括号来避免歧义。宏定义只进行文本替换，不会对参数的类型、语句能否正常编译等进行检查，因此在实际使用宏时非常容易出错。而内联函数是真正的函数，会对参数的类型、函数体内的语句编写是否正确等进行检查。
* 内联函数可以进行调试，宏定义的“函数”无法调试。
* 由于类的成员函数全部为内联函数，通过内联函数，可以访问类的数据成员，而宏不能访问类的数据成员。
* 在 `inline` 函数传递参数只计算一次，而在使用宏定义的情况下，每次在程序中使用宏时都会计算表达式参数，因此宏会对表达式参数计算多次。

参考资料：

* [Inline Functions in C++](https://leetcode.cn/link/?target=https://www.***.org/inline-functions-cpp/?ref=gcse)
* [Inline function](https://leetcode.cn/link/?target=https://en.wikipedia.org/wiki/Inline_function)
* [inline 作用及使用方法](https://leetcode.cn/link/?target=https://www.***.org/difference-between-inline-and-macro-in-c/?ref=gcse)



#### 11. C 和 C++ struct 的区别 4

面试高频指数：★★★★☆

* 在 `C<span> </span>`语言中 struct 是用户自定义数据类型；在 `C++` 中 `struct` 是抽象数据类型，支持成员函数的定义。`C++` 中的 `class` 可以实现 `struct` 的所有功能，`C++` 为了兼容 `C` 语言保留了 `struct` 关键字。
* `C` 语言中 `struct` 没有访问权限的设置，是一些变量的集合体，不能定义成员函数；`C++` 中 `struct` 可以和类一样，有访问权限，并可以定义成员函数。
* `C` 语言中 `struct` 定义的自定义数据类型，在定义该类型的变量时，需要加上 `struct` 关键字，例如：`struct A var;`，定义 `A` 类型的变量；而 `C++` 中，不用加该关键字，例如：`A var`。
* `C++` 中 `struct` 可以继承，也可以实现多态，而 `C` 语言中不支持继承和多态。

参考资料：

* [【C++】struct和class的区别](https://leetcode.cn/link/?target=https://zhuanlan.zhihu.com/p/47808468)

#### 12. extern C 的作用 4

面试高频指数：★★★★☆

`C` 和 `C++` 对同一个函数经过编译后生成的函数名是不同的，由于 `C++` 支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的函数名中，而不仅仅是原始的函数名。比如以下函数，同一个函数 `test` 在 `C++` 编译后符号表中生成的函数名可能为 `_Z4testv`，而 `C` 编译后符号表中生成的函数名可能为 `test`。
比如同一个函数:

```
int test() {
    return 0;
}
```

* 由于 `C` 语言并不支持函数重载，在 `C` 语言中函数不能重名，因此编译 `C` 语言代码的函数时不会带上函数的参数类型，一般只包括函数名。如果在 `C++` 中调用一个使用 `C` 语言编写的模块中的某个函数 `test`，`C++` 是根据 `C++` 的函数名称修饰方式来查找并链接这个函数，去在生成的符号表查找 `_Z4testv` 这个函数的代码，此时就会发生链接错误。而此时我们用 `extern C` 声明，那么在链接时，`C++` 编译器则按照 `C` 语言的函数命名规则 `test` 去符号表中查找对应的函数。因此当 `C++` 程序需要调用 `C` 语言编写的函数，`C++` 使用链接指示，即 `extern "C"` 指出任意非 `C++` 函数所用的语言。

```
// 可能出现在 C++ 头文件<cstring>中的链接指示
extern "C"{
    int strcmp(const char*, const char*);
}

```

参考资料：

* [extern (C++)](https://leetcode.cn/link/?target=https://docs.microsoft.com/en-us/cpp/cpp/extern-cpp?view=msvc-170)

#### 13. struct 和 union 的区别 4

面试高频指数：★★★★☆

* `union` 是联合体，`struct` 是结构体。`union` 中的所有成员变量共享同一段内存空间，`struct` 中的每个成员变量独占内存空间。
* 联合体和结构体都是由若干个数据类型不同的数据成员组成。使用时，联合体只有一个有效的成员；而结构体所有的成员都有效。
* 对联合体的不同成员赋值，将会对覆盖其他成员的值，而对于结构体的对不同成员赋值时，相互不影响。
* 联合体的大小为其内部所有变量的最大值，按照最大类型的倍数进行分配大小；结构体分配内存的大小遵循内存对齐原则。
* `struct` 可以定义变长数组成员变量 `int a[]`，`union` 中不能包含有这种不确定长度的变量。
  以下为示例程序:

```
#include <iostream>
using namespace std;

typedef union
{
    char c[10];
    char cc1; // char 1 字节，按该类型的倍数分配大小
} u11;

typedef union
{
    char c[10];
    int i; // int 4 字节，按该类型的倍数分配大小
} u22;

typedef union
{
    char c[10];
    double d; // double 8 字节，按该类型的倍数分配大小
} u33;

typedef struct s1
{
    char c;   // 1 字节
    double d; // 1（char）+ 7（内存对齐）+ 8（double）= 16 字节
} s11;

typedef struct s2
{
    char c;   // 1 字节
    char cc;  // 1（char）+ 1（char）= 2 字节
    double d; // 2 + 6（内存对齐）+ 8（double）= 16 字节
} s22;

typedef struct s3
{
    char c;   // 1 字节
    double d; // 1（char）+ 7（内存对齐）+ 8（double）= 16 字节
    char cc;  // 16 + 1（char）+ 7（内存对齐）= 24 字节
} s33;

int main()
{
    cout << sizeof(u11) << endl; // 10
    cout << sizeof(u22) << endl; // 12
    cout << sizeof(u33) << endl; // 16
    cout << sizeof(s11) << endl; // 16
    cout << sizeof(s22) << endl; // 16
    cout << sizeof(s33) << endl; // 24

    cout << sizeof(int) << endl;    // 4
    cout << sizeof(double) << endl; // 8
    return 0;
}

```

参考资料：

* [Difference between Structure and Union in C](https://leetcode.cn/link/?target=https://www.***.org/difference-structure-union-c/)
* [Difference Between Structure and Union in C](https://leetcode.cn/link/?target=https://www.guru99.com/difference-structure-union-c.html)
* [Understanding the Difference Between Structure and Union in C](https://leetcode.cn/link/?target=https://www.naukri.com/learning/articles/difference-between-structure-and-union-in-c/)

#### 14. strcpy 函数的缺陷 4

面试高频指数：★★★★☆

1. `strcpy` 函数的实现:
   `strcpy` 是 `C++` 语言的一个标准函数 ，`strcpy` 把含有 `'\0'` 结束符的字符串复制到另一个地址空间，返回值的类型为 `char*`，返回值为拷贝后的字符串的首地址。

```
char * strcpy(char * strDest,const char * strSrc) {
    if ((NULL==strDest) || (NULL==strSrc)) 
    throw "Invalid argument(s)"; 
    char * strDestCopy = strDest; 
    while ((*strDest++=*strSrc++)!='\0'); 
    return strDestCopy;
}

```

2. `strcpy` 函数的缺陷：`strcpy` 函数不检查目的缓冲区的大小边界，而是将源字符串逐一的全部赋值给目的字符串地址起始的一块连续的内存空间，同时加上字符串终止符，会导致其他变量被覆盖。

```
#include <iostream>
#include <cstring>
using namespace std;

int main()
{
    int var = 0x11112222;
    char arr[10];
    cout << "Address : var " << &var << endl;
    cout << "Address : arr " << &arr << endl;
    strcpy(arr, "hello world!");
    cout << "var:" << hex << var << endl; // 将变量 var 以 16 进制输出
    cout << "arr:" << arr << endl;
    return 0;
}

/*
Address : var 0x23fe4c
Address : arr 0x23fe42
var:11002164
arr:hello world!
*/

```

说明：从上述代码中可以看出，变量 `var` 的后六位被字符串 `"hello world!"` 的 `"d!\0"` 这三个字符改变，这三个字符对应的 `ascii` 码的十六进制为：`\0(0x00)，!(0x21)，d(0x64)`。
原因：变量 `arr` 只分配的 `10` 个内存空间，通过上述程序中的地址可以看出 `arr` 和 `var` 在内存中是连续存放的，但是在调用 `strcpy` 函数进行拷贝时，源字符串 `"hello world!"` 所占的内存空间为 `13`，因此在拷贝的过程中会占用 `var` 的内存空间，导致 `var` 的后六位被覆盖。由于 `strcpy` 函数存在一定的安全风险，如果使用不当容易出现安全问题，利用 `strcpy` 的特性可以编写 `shellcode` 来进行缓冲区溢出攻击。在大多数工程代码中，为了保证代码的健壮性和安全性，一般会使用 `strncpy` 代替 `strcpy`。

参考资料：

* [strcpy in C/C++](https://leetcode.cn/link/?target=https://www.***.org/strcpy-in-c-cpp/)
* [strcpy](https://leetcode.cn/link/?target=https://cplusplus.com/reference/cstring/strcpy/)

#### 15. lambda 表达式的应用 3

面试高频指数：★★★☆☆

`lambda` 表达式，又被称为 `lambda` 函数或者 `lambda` 匿名函数。
`lambda` 匿名函数的定义:

```
[capture list] (parameter list) -> return type
{
function body;
};
```

其中：

* `capture list`：捕获列表，指 `lambda` 所在函数中定义的局部变量的列表。定义在与 `lambda` 函数相同作用域的参数引用也可以被使用，一般被称作 `closure`（闭包），以下为闭包的常见用法。

```
[]      // 没有定义任何变量。使用未定义变量会引发错误。
[x, &y] // x以传值方式传入（默认），y以引用方式传入。
[&]     // 任何被使用到的外部变量都隐式地以引用方式加以引用。
[=]     // 任何被使用到的外部变量都隐式地以传值方式加以引用。
[&, x]  // x显式地以传值方式加以引用。其余变量以引用方式加以引用。
[=, &z] // z显式地以引用方式加以引用。其余变量以传值方式加以引用。

```

比如下面以引用的方式调用 `a`：

```
int main()
{
    int a = 10;
    auto f = [&a](int x)-> int {
        a = 20;
        return a + x;
    };
    cout<<a<<endl; // 10
    cout<<f(10)<<endl; // 30
    cout<<a<<endl; // 20
    return 0;
}

```

* `return type`、`parameter list`、`function body`：分别表示返回值类型、参数列表、函数体，和普通函数一样。
  举例：

```
#include <iostream>
#include <algorithm>
using namespace std;

int main()
{
    int arr[4] = {4, 2, 3, 1};
    //对 a 数组中的元素进行升序排序
    sort(arr, arr + 4, [=](int x, int y) -> bool{ return x < y; } );
    auto f = [&](int x)-> int {
        return arr[0] + x;
    }

    for(int n : arr){
        cout << n << " ";
    }
    return 0;
}

```

* 需要注意的是 `lambda` 函数按照值方式捕获的环境中的变量，在 `lambda` 函数内部是不能修改的，否则编译器会报错。其值是 `lambda` 函数定义时捕获的值，不再改变。如果在 `lambda` 函数定义时加上 `mutable` 关键字，则该捕获的传值变量在 `lambda` 函数内部是可以修改的，对同一个 `lambda` 函数的随后调用也会累加影响该捕获的传值变量，但对外部被捕获的那个变量本身无影响。

```
#include <iostream> 
using namespace std;
int main()
{
	size_t t = 9;
	auto f = [t]() mutable{
		t++;
		return t; 
	};
	cout << f() << endl; // 10
	t = 100;
	cout << f() << endl; // 11
	cout << "t:" << t << endl; // t: 100
	return 0;
}

```

* 引用捕获可能带来悬挂引用常见于使用 `lambda` 表达式使用引用捕获某个局部变量，而调用 `lambda` 表达式时，局部变量已经被清理导致捕获的引用指向被清理的内存空间，从而产生悬挂引用。比如下面程序实例中，当 `GetFunc` 返回时，`s` 的对象已经被销毁，此时 `s` 的引用则会出现问题，应将其修改为值传递。

```
#include <iostream>
#include <cstring>
#include <functional>

auto GetFunc(){
    std::string s = "112234234234";
    return [&](){ std::cout << s << std::endl; };
}

int main(int, char*[]){
    auto func = GetFunc();
    func();
    return 0;
}

```

* 在 `C++ 14` 以后，`lambda` 函数的形式参数允许泛型和初始化捕获。
  返回值和参数均使用泛型，编译器会根据实际进行类型推导。

```
auto lambda = [](auto x, auto y) {return x + y;}
lambda(1, 2);
lambda(1.0, 2.0);

```

允许在 `lambda` 捕获列表中对变量进行表达式赋值，并且支持定义新的变量并进行初始化。

auto lambda = [value = 1] {return value;}

* `C++ 17` 以后，`lambda` 函数也支持使用用 `constexpr` 修饰，此时 `lambda` 函数内部应当满足 `constexpr` 的要求。

```
int y = 32;
auto answer = [y]() constexpr
{
    int x = 10;
    return y + x;
};

constexpr int Increment(int n)
{
    return [n] { return n + 1; }();
}

```

参考资料：

* [C++11](https://leetcode.cn/link/?target=https://zh.wikipedia.org/wiki/C%2B%2B11)
* [Lambda expressions (since C++11)](https://leetcode.cn/link/?target=https://en.cppreference.com/w/cpp/language/lambda)
* [Lambda expressions in C++](https://leetcode.cn/link/?target=https://docs.microsoft.com/en-us/cpp/cpp/lambda-expressions-in-cpp?view=msvc-170)
* [What is a lambda expression in C++11?](https://leetcode.cn/link/?target=https://stackoverflow.com/questions/7627098/what-is-a-lambda-expression-in-c11)

#### 16. explicit 的作用 3

面试高频指数：★★★☆☆

用来声明类构造函数是显式调用的，而非隐式调用，可以阻止调用构造函数时进行隐式转换和赋值初始化。只可用于修饰单参构造函数，因为无参构造函数和多参构造函数本身就是显式调用的，再加上 `explicit` 关键字也没有什么意义。

隐式转换：

```
#include <iostream>
#include <cstring>
using namespace std;

class A
{
public:
    int var;
    A(int tmp)
    {
        var = tmp;
    }
};
int main()
{
    A ex = 10; // 发生了隐式转换
    return 0;
}


```

上述代码中，`A ex = 10`; 在编译时，进行了隐式转换，将 `10` 转换成 `A` 类型的对象，然后将该对象赋值给 `ex`，等同于如下操作：

```
A ex1(10);
A ex = ex1;
```

为了避免隐式转换，可用 `explicit` 关键字进行声明：

```
#include <iostream>
#include <cstring>
using namespace std;

class A
{
public:
    int var;
    explicit A(int tmp)
    {
        var = tmp;
        cout << var << endl;
    }
};
int main()
{
    A ex(100);
    A ex1 = 10; // error: conversion from 'int' to non-scalar type 'A' requested
    return 0;
}

```

* 在日常使用时一般情况下建议声明 `explicit` 的构造函数，从而可以阻止编译器执行非预期 (往往也不被期望) 的类型转换，因为某些非预期的类型转换可能会引起意向不到的错误。

参考资料：

* [C++ explicit 关键字](https://leetcode.cn/link/?target=https://zhuanlan.zhihu.com/p/52152355)
* [What does the explicit keyword mean?](https://leetcode.cn/link/?target=https://stackoverflow.com/questions/121162/what-does-the-explicit-keyword-mean)
* [explicit specifier
  ](https://leetcode.cn/link/?target=https://en.cppreference.com/w/cpp/language/explicit)

#### 17. define 和 typedef 的区别 3

面试高频指数：★★★☆☆

二者之间的区别:

* `#define` 作为预处理指令，在编译预处理时进行替换操作，不作正确性检查，只有在编译已被展开的源程序时才会发现可能的错误并报错。`typedef` 是关键字，在编译时处理，有类型检查功能，用来给一个已经存在的类型一个别名，但不能在一个函数定义里面使用 `typedef` 。
* `typedef` 用来定义类型的别名，方便使用。`#define` 不仅可以为类型取别名，还可以定义常量、变量、编译开关等。
* `#define` 没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用，如果在 `.cpp` 文件中定义了宏，则在整个文件中都可以使用该宏，如果在 `.h` 文件中定义了宏，则只要包含该头文件都可以使用；而 `typedef` 有自己的作用域，如果在函数之外定义了类型，则在整个文件中都可以使用该类型定义，如果在函数内部定义了该类型，则只能在函数内部使用该类型。
* 指针的操作：`typedef` 和 `#define` 在处理指针时不完全一样。比如以下程序：

```
#include <stdio.h>
typedef char* ptr;
#define PTR char*
int main()
{
	ptr a, b, c;
	PTR x, y, z;
	printf("sizeof a:%zu\n" ,sizeof(a) );
	printf("sizeof b:%zu\n" ,sizeof(b) );
	printf("sizeof c:%zu\n" ,sizeof(c) );
	printf("sizeof x:%zu\n" ,sizeof(x) );
	printf("sizeof y:%zu\n" ,sizeof(y) );
	printf("sizeof z:%zu\n" ,sizeof(z) );
	return 0;
}

```

输出为:

```
sizeof a:8
sizeof b:8
sizeof c:8
sizeof x:8
sizeof y:1
sizeof z:1
```

由于在处理，`typedef` 定义了新的类型，因此变量 `a, b, c` 都属于指针类型，而 `#define` 只是做了简单的替换，被替换为语句 `char *x, y, z` 实际 `y,z` 为 `char` 类型。

参考资料：

* [typedef versus #define in C](https://leetcode.cn/link/?target=https://www.***.org/typedef-versus-define-c/)
* [Difference between typedef and define in C](https://leetcode.cn/link/?target=https://www.javatpoint.com/typedef-vs-define-in-c)

#### 18. inline 函数工作原理 3

面试高频指数：★★★☆☆

1. 内联函数的工作原理：

* 内联函数不是在调用时发生控制转移关系，而是在编译阶段将函数体嵌入到每一个调用该函数的语句块中，编译器会将程序中出现内联函数的调用表达式用内联函数的函数体来替换。函数调用时，需要切换栈帧寄存器，同时栈中压入参数、返回值，然后进行跳转，这些都需要开销，而内联函数则可以不要这些开销，直接将内联函数中函数体直接插入或者替换到该函数调用点。
* 普通函数是将程序执行转移到被调用函数所存放的内存地址，当函数执行完后，返回到执行此函数前的地方。转移操作需要保护现场，被调函数执行完后，再恢复现场，该过程需要较大的资源开销。
* 虽然内联函数在调用时直接进行展开，但实际在编译后代码中存在内联函数的定义，可以供编译器进行调用。普通函数可以有指向它的函数指针，内敛函数也可以有指向它的函数指针。

2. 内联函数的优缺点:

* 内联函数具有以下优点：

  * 不会产生函数调用开销。节省了调用函数时在堆栈上推送/弹出变量的开销。节省了函数返回调用的开销。当你内联一个函数时，你可以让编译器对函数体执行上下文特定的优化，其他优化可以通过考虑调用上下文和被调用上下文的流程来获得，而对于普通函数不会有这种优化。
* 内联函数的缺点：

  * 从内联函数中添加的变量会消耗额外的寄存器，在内联函数之后，如果要使用寄存器的变量数量增加，则可能会在寄存器变量资源利用方面产生开销。在函数调用点替换内联函数体时，函数使用的变量总数也会增加，用于存储变量的寄存器数量也会增加。因此，如果在函数内联变量数量急剧增加之后，它肯定会导致寄存器利用率的开销。
  * 如果你使用太多的内联函数，那么二进制可执行文件的大小会很大，因为相同的代码重复。
  * 过多的内联也会降低指令缓存命中率，从而降低从缓存内存到主内存的指令获取速度。
  * 如果有人更改内联函数内的代码，内联函数可能会增加编译时间开销，那么所有调用位置都必须重新编译，因为编译器需要再次替换所有代码，否则它将继续使用旧功能.
  * 内联函数可能会导致抖动，因为内联可能会增加二进制可执行文件的大小。内存抖动会导致计算机性能下降。

3. `inline` 函数的使用场景：
   内联函数一般只适用于比较短小，处理较为简单的函数。内联只是对编译器的请求，而不是命令。编译器可以忽略内联请求。编译器可能不会在以下情况下执行内联：

* 如果函数包含循环（`for, while, do-while`）；
* 如果一个函数包含静态变量；
* 如果一个函数是递归的；
* 如果函数返回类型不是 `void`，并且函数体中不存在 `return` 语句；
* 如果函数包含 `switch` 或 `goto` 语句；

4. 内联可以去除函数只能定义一次的限制：
   内联函数可以在程序中定义不止一次， 但是 `inline` 函数的定义在某个源文件中只能出现一次，而且在所有源文件中，其定义必须是完全相同的。一般情况下，我们可以在头文件中定义 `inline` 函数，所有 `include` 该头文件，如果修改了头文件中的 `inline` 函数时，使用了该头文件的所有源文件都必须重新编译。比如我们可以在定义以下两个文件包含相同的函数。

```
// b.cpp
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

inline int min(int a, int b) {
    return a + b;
}

// a.cpp
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

inline int min(int a, int b) {
    return a + b;
}

int main() {
    int a = 10, b = 9;
    min(a, b);
    return 0;
}


```

参考资料：

* [Inline Functions in C++](https://leetcode.cn/link/?target=https://www.***.org/inline-functions-cpp/?ref=gcse)
* [Inline function](https://leetcode.cn/link/?target=https://en.wikipedia.org/wiki/Inline_function)

#### 19. class 和 struct 的异同 3

面试高频指数：★★★☆☆

`C++` 中为了兼容 `C` 语言而保留了 `C` 语言的 `struct` 关键字，并且加以扩充。在 `C` 语言中，`struct` 只能包含成员变量，不能包含成员函数。而在 `C++` 中，`struct` 类似于 `class`，既可以包含成员变量，又可以包含成员函数。
`C++` 中的 `struct` 和 `class` 基本是通用的，唯有几个细节不同：

* `class` 中类中的成员默认都是 `private` 属性的；而在 `struct` 中结构体中的成员默认都是 `public` 属性的。
* `class` 继承默认是 `private` 继承，而 `struct` 继承默认是 `public` 继承。
* `class` 可以用于定义模板参数，`struct` 不能用于定义模板参数。

```
struct A{}；
class B : A{}; // private 继承 
struct C : B{}； // public 继承
```

举例：

```
#include<iostream>

using namespace std;

class A{
public:
    void funA(){
        cout << "class A" << endl;
    }
};

struct B: A{ // 由于 B 是 struct，A 的默认继承级别为 public
public:
    void funB(){
        cout << "class B" << endl;
    }
};

class C: B{ // 由于 C 是 class，B 的默认继承级别为 private，所以无法访问基类 B 中的 printB 函数

};

int main(){
    A ex1;
    ex1.funA(); // class A

    B ex2;
    ex2.funA(); // class A
    ex2.funB(); // class B

    C ex3;
    ex3.funB(); // error: 'B' is not an accessible base of 'C'.
    return 0;
}

```

参考资料：

* [Inline Functions in C++](https://leetcode.cn/link/?target=https://www.ibm.com/docs/en/zos/2.3.0?topic=only-classes-structures-c)
* [Difference between Structure and Class in C++](https://leetcode.cn/link/?target=https://www.javatpoint.com/structure-vs-class-in-cpp)

#### 20. 返回函数中静态变量的地址会发生什么 3

面试高频指数：★★★☆☆

```
#include <iostream>
using namespace std;

int * fun(int tmp){
    static int var = 10;
    var *= tmp;
    return &var;
}

int main() {
    cout << *fun(5) << endl;
    return 0;
}

/*
运行结果：
50
*/

```

* 前面的章节中讲过，静态局部变量存在静态区，程序初始化时则已经创建了改变量，变量的生存周期为整个程序的生命周期。上述代码中在函数 `fun` 中定义了静态局部变量 `var`，使得离开该函数的作用域后，该变量不会销毁，返回到主函数中，该变量依然存在，从而使程序得到正确的运行结果，该静态局部变量直到程序运行结束后才销毁。
* 需要注意的是，全局静态对象在程序初始化时，则进行了初始化。局部静态对象的初始化在第一次进入函数内部时，才会调用对象的构造函数进行初始化。程序退出时，先释放静态局部变量，再释放全局静态变量。

参考资料：

* [线程安全：局部静态变量的初始化](https://leetcode.cn/link/?target=https://baijiahao.baidu.com/s?id=1686962192046161801&wfr=spider&for=pc)
* [static初始化](https://leetcode.cn/link/?target=https://zhuanlan.zhihu.com/p/406301228)

#### 21. sizeof(1==1) 在 C 和 C++ 中的结果 3

面试高频指数：★★★☆☆

前面的章节中讲述过 `sizeof` 接受的参数可以是对象也可以是表达式，但是 `sizeof(expression)` 在运行时不会对接受的表达式进行计算，编译器只会推导表达式的类型从而计算占用的字节大小；

```
#include <iostream>
using namespace std;
int main(int argc, char * argv[])
{
    int x = 4;
    sizeof(x++);
    printf("%d\n", x);
    return 0;
}

```

* 由于 `C` 语言没有 `bool` 类型，用整形表示布尔型，因此下面的程序返回 `4`;

```
#include<stdio.h>

void main(){
    printf("%d\n", sizeof(1==1));
}

/*
运行结果：
4
*/

```

* 由于 `C++` 语言有 `bool` 类型，布尔型占 `1` 个字节，因此下面的程序返回 `1`;

```
#include <iostream>
using namespace std;

int main() {
    cout << sizeof(1==1) << endl;
    return 0;
}

/*
1
*/

```

参考资料：

* [sizeof operator in C](https://leetcode.cn/link/?target=https://www.***.org/sizeof-operator-c/)

#### 22. memmove 函数的底层原理 3

面试高频指数：★★★☆☆

* `memmove` 用于拷贝字节，如果目标区域和源区域有重叠的话，`memmove` 能够保证源串在被覆盖之前将重叠区域的字节拷贝到目标区域中，但复制后源内容会被更改。但是当目标区域与源区域没有重叠则和 `memcpy` 函数功能相同。面试时会经常要求实现 `memmove` 函数，在实现的时候需要特殊处理地址重叠的情况。

```
void *memmove(void *dst, const void *src, size_t size)
{
    char *psrc;
    char *pdst;

    if (NULL == dst || NULL == src)
    {
        return NULL;
    }

    if ((src < dst) && (char *)src + size > (char *)dst) // 出现地址重叠的情况，自后向前拷贝
    {
        psrc = (char *)src + size - 1;
        pdst = (char *)dst + size - 1;
        while (size--)
        {
            *pdst-- = *psrc--;
        }
    }
    else
    {
        psrc = (char *)src;
        pdst = (char *)dst;
        while (size--)
        {
            *pdst++ = *psrc++;
        }
    }

    return dst;
}

```

参考资料：

* [memmove() in C/C++](https://leetcode.cn/link/?target=https://www.***.org/memmove-in-cc/?ref=gcse)

#### 23. new 的作用 2

面试高频指数：★★☆☆☆

1. `new` 的简介：
   `new` 是 `C++` 中的关键字，尝试分配和初始化指定或占位符类型的对象或对象数组，并返回指向对象 (或数组的初始对象) 的指针。

* 用 `new` 创建对象时，首先从堆中申请相应的内存空间，然后调用对象的构造函数，最后返回指向对象的指针。`new` 操作符从自由存储区（`free store`）上为对象动态分配内存空间，而 `malloc` 函数从堆上动态分配内存。自由存储区是 `C++` 基于 `new` 操作符的一个抽象概念，凡是通过 `new` 操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，`C` 语言使用 `malloc` 从堆上分配内存，使用 `free` 释放已分配的对应内存。`new` 可以指定在内存地址空间创建对象，用法如下:

```
new (place_address) type
```

`place_address` 为一个指针，代表一块内存的地址。当使用上面这种仅以一个地址调用 `new` 操作符时，`new` 操作符调用特殊的 `operator new`：

```
void * operator new (size_t, void *) 
```

对于指定的地址的 `new` 对象，在释放时，不能直接调用 `delete`, 应该先调用对象的析构函数，然后再对内存进行释放。比如以下程序:

```
include <iostream>
using namespace std;

int main(int argc, char* argv[])
{
    char buf[100];
    int *p=new (buf) int(101);
    cout<<*(int*)buf<<endl;
    return 0;
}

```

* `new` 可以用来动态生成对象数组，但此时 `new` 生成的数组，只能用 `delete` 来释放。

```
int *arr = new int [100];
```

* 在 `cpp` 中由于 `new` 作为操作符可以进行重载，所以可以对 `new` 进行重载，比如可以指定构造函数对对象进行初始化。对 `new` 操作符可以进行全局重载和局部重载，全局重载后，所有调用 `new` 的操作都会被重写；局部重载就是在类中重写 `operator new` 函数，但只会对该类生效，即该类执行 `new` 操作时会生效。

```
#include <iostream>

class Test {
private:
    int value;

public:
    Test() {
        printf("[Test] Constructor\n");
    }

    void* operator new(size_t size) {
        printf("[Test] operator new\n");
        return NULL;
    }
};

int main() 
{ 
    Test* t = new Test();
    return 0;
}

// [Test] operator new
// [Test] Constructor

```

参考资料：

* [new (C++)](https://leetcode.cn/link/?target=https://zh.m.wikipedia.org/zh/New_(C%2B%2B))
* [C++ new的三种面貌](https://leetcode.cn/link/?target=https://cloud.tencent.com/developer/article/1177460)
* [new 运算符 (C++)](https://leetcode.cn/link/?target=https://docs.microsoft.com/zh-cn/cpp/cpp/new-operator-cpp?view=msvc-170)
* 在日常使用时一般情况下建议声明 `explicit` 的构造函数，从而可以阻止编译器执行非预期 (往往也不被期望) 的类型转换，因为某些非预期的类型转换可能会引起意向不到的错误。

参考资料：

* [C++ explicit 关键字](https://leetcode.cn/link/?target=https://zhuanlan.zhihu.com/p/52152355)
* [What does the explicit keyword mean?](https://leetcode.cn/link/?target=https://stackoverflow.com/questions/121162/what-does-the-explicit-keyword-mean)
* [explicit specifier](https://leetcode.cn/link/?target=https://en.cppreference.com/w/cpp/language/explicit)

[](https://leetcode.cn/leetbook/read/cmian-shi-tu-po/vwegz6/)

* 在日常使用时一般情况下建议声明 `explicit` 的构造函数，从而可以阻止编译器执行非预期 (往往也不被期望) 的类型转换，因为某些非预期的类型转换可能会引起意向不到的错误。

参考资料：

* [C++ explicit 关键字](https://leetcode.cn/link/?target=https://zhuanlan.zhihu.com/p/52152355)
* [What does the explicit keyword mean?](https://leetcode.cn/link/?target=https://stackoverflow.com/questions/121162/what-does-the-explicit-keyword-mean)
* [explicit specifier](https://leetcode.cn/link/?target=https://en.cppreference.com/w/cpp/language/explicit)

[](https://leetcode.cn/leetbook/read/cmian-shi-tu-po/vwegz6/)
